[
["index.html", "blogdown: Creación de sitios web con R Markdown Prefacio", " blogdown: Creación de sitios web con R Markdown Yihui Xie, Amber Thomas, Alison Presmanes Hill 2018-03-31 Prefacio En el verano de 2012, Yihui Xie hizo su internado en los laboratorios de investigación AT&amp;T, donde asistió a una charla de Carlos Scheidegger (https://cscheid.net), y Carlos dijo algo asó como que “si no tienes un sitio web, hoy en día, no existes”. Luego lo parafraseé como: “Hago web, por ende soy spiderman.” Las palabras de Carlos sonaron muy bien, aunque fueron un poco exageradas. Un sitio web bien diseñado y mantenido puede ser extremadamente útil para que otras personas lo conozcan, y usted no necesita esperar oportunidades adecuadas en conferencias u otras ocasiones para presentarse en persona a los demás. Por otro lado, un sitio web también es muy útil para que usted realice un seguimiento de lo que ha hecho y ha pensado. A veces puede regresar a una determinada publicación anterior suya para volver a aprender los trucos o métodos que una vez dominó en el pasado pero que olvidó. En este libro, se presenta un paquete de R, blogdown, para enseñarle cómo crear sitios web usando R Markdown y Hugo. Si tiene experiencia en la creación de sitios web, naturalmente puede preguntarse sobre cuáles son los beneficios de usar R Markdown y cómo blogdown es diferente de las plataformas de sitios web populares existentes, como WordPress. Hay dos aspectos principales de blogdown: Produce un sitio web estático, lo que significa que el sitio web solo consta de archivos estáticos como HTML, CSS, JavaScript e imágenes, etc. Puede alojar el sitio web en cualquier servidor web (consulte el Capítulo ?? para obtener más información). El sitio web no requiere scripts del lado del servidor como PHP o bases de datos como WordPress. Es solo una carpeta de archivos estáticos. Se explicarán más beneficios de los sitios web estáticos en el Capítulo 2, cuando se presente el generador de sitios web estáticos Hugo. El sitio web se genera a partir de documentos R Markdown (R es opcional, es decir, puede usar documentos de Markdown sin fragmentos de código R). Esto brinda una gran cantidad de beneficios, especialmente si su sitio web está relacionado con el análisis de datos o la programación (en R). Poder utilizar Markdown implica simplicidad y, lo que es más importante, portabilitdad (por ejemplo, se está dando la oportunidad de convertir sus publicaciones de blog a formato PDF y publicarlas en revistas o incluso libros en el futuro). R Markdown le brinda los beneficios de los documentos dinámicos — todos sus resultados, tales como tablas, gráficos y valores en línea, se pueden calcular y representar dinámicamente desde el código en R, por lo tanto, es más probable que los resultados que presente en su sitio web sean reproducibles. Un beneficio adicional pero importante de usar R Markdown es que podrá escribir documentos técnicos fácilmente, debido a que blogdown hereda el formato de salida HTML de bookdown (Xie 2016). Por ejemplo, es posible escribir ecuaciones matemáticas LaTeX, citas en BibTeX e incluso teoremas y pruebas si lo desea. No se deje engañar por la palabra “blog” en el nombre del paquete: blogdown es para sitios web de propósito general, y no solo para blogs. Por ejemplo, todos los autores de este libro tienen sus sitios web personales, donde puede encontrar información sobre sus proyectos, blogs, documentación de paquetes, etc.1 Todas sus páginas están compiladas a partir de blogdown y Hugo. Si no prefiere usar Hugo, también existen otras opciones. El capítulo 5 presenta posibilidades para usar otros generadores de sitios web, tales como Jekyll y el generador por defecto de rmarkdown. Este libro ha sido publicado por Chapman &amp; Hall/CRC. La versión en línea de este libro está licenciada bajo Licencia Internacional Creative Commons Attribution-NonCommercial-ShareAlike 4.0. References "],
["estructura-del-libro.html", "Estructura del libro", " Estructura del libro El capítulo ?? tiene como objetivo comenzar con un nuevo sitio web basado en blogdown: contiene una guía de instalación, un ejemplo rápido, una introducción a los complementos de RStudio relacionados con blogdown, y comparaciones de diferentes formatos de documentos de origen. Todos los lectores de este libro deben terminar al menos este capítulo (para saber cómo crear un sitio web localmente) y la sección 3.1 (para saber cómo publicar un sitio web). El resto del libro es principalmente para aquellos que desean personalizar aún más sus sitios web. El capítulo 2 presenta brevemente el generador de sitios web estáticos Hugo, en el que se basa blogdown. Se intentó resumir la documentación oficial de Hugo en un breve capítulo. Debe consultar la documentación oficial en caso de duda. Puede omitir la sección 2.5 si no tiene conocimientos básicos de tecnologías web. Sin embargo, esta sección es crítica para que entienda completamente Hugo. Se ha invertido la mayor parte del tiempo en esta sección de este capítulo. Es muy técnico, pero debería ser útil, no obstante. Una vez que haya aprendido cómo crear plantillas Hugo, tendrá la plena libertad de personalizar su sitio web. El capítulo ?? le dice cómo publicar un sitio web, para que otras personas puedan visitarlo a través de un enlace. El capítulo ?? muestra cómo migrar sitios web existentes desde otras plataformas a Hugo y blogdown. El capítulo 5 ofrece algunas otras opciones si no desea usar Hugo como su generador de sitios. El Apéndice A es un tutorial rápido sobre R Markdown, el requisito previo de blogdown si va a escribir código R en sus publicaciones. El Apéndice ?? contiene conocimientos básicos sobre sitios web, como HTML, CSS y JavaScript. Si realmente le importa su sitio web, tendrá que aprenderlo algún día. Si desea tener su propio nombre de dominio, el Apéndice @ref (nombre-dominio) proporciona una introducción. También hemos cubierto algunos temas opcionales en el Apéndice ?? para usuarios avanzados. "],
["software-info.html", "Información de Software y convenciones", " Información de Software y convenciones La información de la sesión de R al compilar este libro se muestra a continuación: sessionInfo() ## R version 3.4.3 (2017-11-30) ## Platform: x86_64-apple-darwin15.6.0 (64-bit) ## Running under: macOS High Sierra 10.13.3 ## ## Matrix products: default ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets ## [6] base ## ## loaded via a namespace (and not attached): ## [1] bookdown_0.7 blogdown_0.5 rmarkdown_1.9 ## [4] htmltools_0.3.6 knitr_1.20 No agregamos avisos (&gt; y +) al código fuente en R de este libro, y comentamos el resultado de texto con dos numerales ## por defecto, como puede ver en la información de la sesión en R anterior. Esto es para su conveniencia cuando quiera copiar y ejecutar el código (la salida de texto será ignorada ya que está comentada). Los nombres de los paquetes están en negrita (por ejemplo, rmarkdown), y el código en línea y los nombres de los archivos están formateados en una fuente de máquina de escribir (por ejemplo, knitr::knit('foo.Rmd')). Los nombres de las funciones están seguidos por paréntesis (por ejemplo, blogdown::serve_site()). El operador doble punto :: significa acceder a un objeto desde un paquete. Una barra inclinada a menudo indica un nombre de directorio, por ejemplo, content/ significa un directorio llamado content en lugar de un archivo llamado content. Una barra diagonal en una ruta indica el directorio raíz del sitio web, por ejemplo, /static/css/style.css significa el archivostatic/css/style.css bajo el directorio raíz de su proyecto de sitio web en lugar de que esté bajo su sistema operativo. Tenga en cuenta que algunos nombres de directorios son configurables, como public/, pero usaremos sus valores predeterminados en todo el libro. Por ejemplo, su sitio web se presentará en el directorio public/ de forma predeterminada, y cuando vea public/ en este libro, debería considerarlo como el directorio de publicación real que estableció si cambió el valor predeterminado. Rmd significa R Markdown en este libro, y es la extensión del nombre de archivo de R Markdown. Una “publicación” a menudo no significa literalmente una publicación de blog, sino que se refiere a cualquier documento fuente (Markdown o R Markdown) en el proyecto del sitio web, incluidas publicaciones de blog y páginas normales. Normalmente, las publicaciones de blog se almacenan en el directorio content/post/, y las páginas están en otros directorios (incluido el directorio raíz content/ y sus subdirectorios), pero Hugo no requiere esta estructura. La URL http://www.example.com se usa solo con fines ilustrativos. No queremos decir que realmente deba visitar este sitio web. En la mayoría de los casos, debe reemplazar www.example.com con su nombre de dominio real. Un asterisco * en una cadena de caracteres a menudo significa una cadena arbitraria. Por ejemplo, *.example.com denota un subdominio arbitrario de example.com. Podría ser foo.example.com o 123.example.com. En realidad, foo y bar también indican caracteres u objetos arbitrarios. "],
["agradecimientos.html", "Agradecimientos", " Agradecimientos Originalmente, Yihui planeó escribir solo una oración en esta sección: “Agradezco a Tareef”. Este libro y el paquete blogdown no se habrían terminado sin Tareef, el presidente de RStudio. Él ha estado “empujándolo suavemente” todas las semanas desde el Día 1 de blogdown. Como una persona sin una gran autodisciplina y trabajando de forma remota, Yihui se benefició mucho de las reuniones semanales con Tareef. También le dio muchas buenas sugerencias técnicas para mejorar el paquete. En realidad, fue uno de los primeros usuarios de blogdown. Por supuesto que a Yhui le gustaría agradecer a RStudio por la maravillosa oportunidad de trabajar en este nuevo proyecto. Él estaba aún más entusiasmado con blogdown que bookdown (su proyecto anterior). Él empezó a bloguear hace 12 años y ha usado y dejado varias herramientas para crear sitios web. Finalmente Yhui se siente satisfecho con su propia “comida para perros”. Muchos usuarios han suministrado valiosa retroalimentación y han reportado problemas a través de GitHub issues (https://github.com/rstudio/blogdown/issues). Dos de los favoritos de Yihui son https://github.com/rstudio/blogdown/issues/40 y https://github.com/rstudio/blogdown/issues/97. Algunos usuarios también han contribuido con código y han mejorado este libro a través de pull requests (https://github.com/rstudio/blogdown/pulls). Puede encontrar la lista de contribuyentes en https://github.com/rstudio/blogdown/graphs/contributors. Muchos usuarios siguieron la sugerencia de formular preguntas en StackOverflow (https://stackoverflow.com/tags/blogdown) en lugar de usar GitHub issues o correos electrónicos. Yihui aprecia su ayuda, paciencia y comprensión. Él también quisiera hacer una mención especial a su pequeño amigo Jerry Han, quien fue, probablemente, el usuario de blogdown más joven. Para este libro, Yihui tuvo la suerte de trabajar con sus coautores, Amber y Alison, que son excepcionalmente buenas para explicar las cosas a los principiantes. Esa es la habilidad que más deseo. Huelga decir que han hecho este libro más amigable para principiantes. Además, Sharon Machlis contribuyó con algunos consejos sobre optimización de motores de búsqueda en este libro (https://github.com/rstudio/blogdown/issues/193). Raniere Silva contribuyó con la sección 3.5 (https://github.com/rstudio/blogdown/pull/225). A Yihui le gustaría agradecer a todos los autores y colaboradores de Hugo (Bjørn Erik Pedersen y Steve Francia et al.) por su potente generador de sitios estáticos. Al menos le hizo disfrutar construyendo sitios web estáticos y blogs, nuevamente. Por alguna razón, una parte de la comunidad de R comenzó a adoptar el modelo de “desarrollo impulsado por stickers” al desarrollar paquetes. Esperaba que blogdown también tuviera un sticker, así que Yihui pidió ayuda en Twitter (https://twitter.com/xieyihui/status/907269861574930432) y obtuvo toneladas de borradores de logotipos. En particular, quisiera agradecer a Thomas Lin Pedersen por su arduo trabajo en un diseño muy inteligente. La versión final del logotipo fue proporcionada por Taras Kaduk y Angelina Kaduk, y realmente lo aprecia. Este es el tercer libro que Yihui ha publicado con su editor en Chapman &amp; Hall/CRC, John Kimmel. Siempre le ha gustado trabajar con él. Rebecca Condit y Suzanne Lassandro revisaron el manuscrito y aprendió mucho de sus comentarios y sugerencias profesionales. Yihui Xie Elkhorn, Nebraska "],
["author.html", "Sobre los autores", " Sobre los autores Yihui es el desarrollador principal del paquete blogdown. No comenzó a trabajar en la documentación sistemática (es decir, este libro) hasta cuatro meses después de comenzar el proyecto blogdown. Un día, encontró un tutorial de blogdown muy agradable en Twitter escrito por Amber Thomas. Sorprendido de que pudiera crear un gran sitio web personal usando blogdown y escribir un tutorial cuando no había documentación oficial, Yihui inmediatamente la invitó a unirse a él para escribir este libro, aunque nunca antes se habían conocido. Esto definitivamente no habría sucedido si Amber no tuviera un sitio web. Por cierto, Amber formuló la primera pregunta con la etiqueta blogdown en StackOverflow. Alrededor de medio año después, Yihui vio otro tutorial de blogdown muy bien escrito por Alison en su sitio web personal, cuando este libro todavía no estaba completo. Sucedió lo mismo, y Alison se convirtió en el tercer autor de este libro. Los tres autores no se conocían. Con suerte, puede ver mejor por qué debería tener un sitio web ahora. "],
["yihui-xie.html", "Yihui Xie", " Yihui Xie Yihui Xie (https://yihui.name) es ingeniero de software en RStudio (https://www.rstudio.com). Obtuvo su doctorado en el Departamento de Estadística de la Universidad Estatal de Iowa. Está interesado en gráficos estadísticos interactivos y computación estadística. Como usuario de R activo, es autor de varios paquetes en R, como knitr, bookdown, blogdown, xaringan, animation, DT, tufte, formatR, fun, mime, highr, servr, y Rd2roxygen, entre los cuales animation ganó el premio John M. Chambers Statistical Software Award (ASA) 2009 . También fue coautor de algunos otros paquetes R, entre los que se incluyen shiny, rmarkdown y leaflet. En 2006, fundó Capital of Statistics (https://cosx.org), que se ha convertido en una gran comunidad en línea de estadísticas en China. Inició la conferencia de R de China en 2008 y desde entonces ha participado en la organización de conferencias de R en China. Durante su formación de doctorado en la Iowa State University, ganó el Vince Sposito Statistical Computing Award (2011) y el Snedecor Award (2012) en el Departamento de Estadística. De vez en cuando despotrica en Twitter (https://twitter.com/xieyihui), y la mayoría de las veces lo pueden encontrar en GitHub (https://github.com/yihui). Le gusta la comida picante tanto como la literatura china clásica. "],
["amber-thomas.html", "Amber Thomas", " Amber Thomas Amber Thomas (https://amber.rbind.io) es periodista de datos y “creadora” de la publicación en línea de ensayos visuales: The Pudding (https://pudding.cool). Sin embargo, su formación académica se encontraba en un campo completamente diferente: la biología marina. Tiene una licenciatura en biología marina y química de la Universidad Roger Williams y una maestría en ciencias marinas de la Universidad de Nueva Inglaterra. A lo largo de su carrera académica y profesional como bióloga marina, se dio cuenta de que amaba el análisis de datos, la visualización y la narración de historias a través de los datos y, por lo tanto, cambió las trayectorias profesionales por algo un poco más centrado en los datos. Mientras buscaba trabajo, comenzó a realizar proyectos personales para ampliar su conocimiento del funcionamiento interno de R. Decidió poner todos sus proyectos en un solo lugar en línea (para que pudiera ser descubierta, naturalmente) y después de muchas búsquedas, tropezó con un lanzamiento anticipado del paquete blogdown. Se enganchó de inmediato y pasó unos días configurando su sitio web personal y escribiendo un tutorial sobre cómo lo hizo. Puede encontrar ese tutorial y algunos de sus otros proyectos y reflexiones en su sitio de blogdown. Cuando no está machacando números y tratando de mantenerse al tanto de la bandeja de entrada de su correo electrónico, por lo general, Amber recibe aire fresco de Seattle o se acurruca con su perro, Sherlock. Si la está buscando en el mundo digital, pruebe https://twitter.com/ProQuesAsker. "],
["alison-presmanes-hill.html", "Alison Presmanes Hill", " Alison Presmanes Hill Alison (https://alison.rbind.io) es profesora de pediatría en el Centro para el Entendimiento del Lenguaje Hablado de la Universidad de Salud y Ciencia de Oregon (OHSU, por sus siglas en inglés) en Portland, Oregon. Alison obtuvo su doctorado en psicología del desarrollo con una concentración en métodos cuantitativos de la Universidad de Vanderbilt en 2008. Su investigación actual se centra en desarrollar mejores medidas de resultado para evaluar el impacto de nuevos tratamientos para niños con autismo y otros trastornos del neurodesarrollo, utilizando procesamiento del lenguaje natural y otros métodos computacionales. Alison es autora de numerosos artículos de revistas y capítulos de libros, y su trabajo ha sido financiado por los Institutos Nacionales de Salud, el Instituto de Investigación Translacional y Clínica de Oregón y Autism Speaks. Además de la investigación, Alison imparte cursos de postgrado en el programa de Ciencias de la Computación de OHSU (https://www.ohsu.edu/csee) sobre estadística, ciencia de datos y visualización de datos usando R. También ha desarrollado y dirigido varios talleres de R y sesiones de entrenamiento en equipos más pequeñas, y le encanta entrenar nuevos “usuarios”. Puede encontrar algunos de sus talleres y materiales de enseñanza en GitHub (https://github.com/apreshill) y, por supuesto, en su sitio blogdown. Siendo una madre nueva, los libros favoritos actuales de Alison son The Circus Ship y Bats at the Ballgame. También realiza interpretaciones entusiastas de la mayoría de las canciones de Emily Arrow (solo para audiencias privadas). "],
["comienzo.html", "Capítulo 1 Comienzo", " Capítulo 1 Comienzo En este capítulo, mostramos cómo crear un sitio web simple desde cero. El sitio web contendrá una página de inicio, una página “Acerca de”, una publicación de R Markdown y una publicación de markdown normal. Aprenderá los conceptos básicos para crear sitios web con blogdown. Para principiantes, le recomendamos que comience con RStudio IDE, pero realmente no es necesario. RStudio IDE puede facilitar algunas cosas, pero puede usar cualquier editor si no le importan los beneficios adicionales en RStudio. "],
["instalacion.html", "1.1 Instalación", " 1.1 Instalación Asumimos que ya ha instalado R (https://www.r-project.org) (R Core Team 2017) y RStudio IDE (https://www.rstudio.com). Si no tiene instalado RStudio IDE, instale Pandoc (http://pandoc.org). A continuación, tenemos que instalar el paquete blogdown en R. Está disponible en CRAN y GitHub, y puede instalarlo con: ## Intalación desde el CRAN install.packages(&#39;blogdown&#39;) ## O, instalación desde GitHub if (!requireNamespace(&quot;devtools&quot;)) install.packages(&#39;devtools&#39;) devtools::install_github(&#39;rstudio/blogdown&#39;) Como blogdown se basa en el generador de sitios estáticos Hugo (https://gohugo.io), también debe instalar Hugo. Hay una función auxiliar en blogdown para descargar e instalar automáticamente en los principales sistemas operativos (Windows, MacOS y Linux): blogdown::install_hugo() Por defecto, instala la última versión de Hugo, pero puede elegir una versión específica a través del argumento versión, si lo prefiere. Para los usuarios de macOS, install_hugo() usa el administrador de paquetes Homebrew (https://brew.sh) si ya se ha instalado, de lo contrario solo descarga el binario de Hugo directamente. 1.1.1 Actualización Para actualizar o reinstalarHugo, use blogdown::update_hugo(), que es equivalente a install_hugo(force = TRUE). Puede verificar la versión de Hugo instalada mediante blogdown::hugo_version(), y encontrar la última versión de Hugo en https://github.com/gohugoio/hugo/releases. References "],
["un-ejemplo-rapido.html", "1.2 Un ejemplo rápido", " 1.2 Un ejemplo rápido Según nuestra experiencia, la documentación de Hugo puede ser un poco desalentadora para leer y digerir para principiantes.2 Por ejemplo, su guía de “Inicio rápido” solía tener 12 pasos, y usted puede perderse fácilmente si no ha utilizado un generador de sitio web estático antes. Para blogdown, esperamos que los usuarios de todos los niveles al menos puedan comenzar lo más rápido posible. Hay muchas cosas que puede desear modificar para el sitio web más adelante, pero el primer paso es bastante simple: crear un nuevo proyecto en un directorio nuevo en RStudio IDE (File -&gt; New Project) y llamar a la función en la consola de R del nuevo proyecto: blogdown::new_site() Luego espere a que esta función cree un sitio nuevo, descargue el tema predeterminado, agregue algunas publicaciones de muestra, ábralas, cree el sitio y ejecútelo en RStudio Viewer, para que pueda obtener una vista previa de inmediato. Si no usa RStudio IDE, necesita asegurarse de que se encuentra actualmente en un directorio vacío,3 en cuyo caso new_site() hará lo mismo, pero el sitio web se lanzará en su navegador web en lugar de RStudio Viewer. Ahora debería ver un grupo de directorios y archivos en el proyecto RStudio o en su directorio de trabajo actual. Antes de explicar estos nuevos directorios y archivos, primero introduzcamos una tecnología importante y útil: LiveReload. Esto significa que su sitio web4 Se reconstruirá y volverá a cargar automáticamente en su navegador web5 Cuando modifique cualquier archivo fuente de su sitio web y lo guarde. Básicamente, una vez que inicie el sitio web en un navegador web, ya no necesita volver a generarlo explícitamente. Todo lo que necesita hacer es editar los archivos fuente, como los documentos R Markdown, y guardarlos. No es necesario hacer clic en ningún botón ni ejecutar ningún comando. LiveReload se implementa a través de blogdown::serve_site(), que está basado en el paquete de R servr (Xie 2018c) de manera predeterminada.6 La función new_site() tiene varios argumentos, y puede revisar su página de ayuda de R (?blogdown::new_site) para más detalles. Un tema predeterminado mínimo llamado “hugo-lithium-theme” se proporciona como el tema predeterminado del nuevo sitio,7 Y se puede ver cómo se ve en Figure 1.1. FIGURA 1.1: La página de inicio del nuevo sitio por defecto. Tiene que saber tres conceptos más básicos para un sitio web basado en Hugo: El archivo de configuración config.toml, en el que puede especificar algunas configuraciones globales para su sitio. Incluso si no sabe qué es TOML en este momento (se presentará en el capítulo 2), aún podrá cambiar algunas configuraciones obvias. Por ejemplo, puede ver configuraciones como estas en config.toml: baseurl = &quot;/&quot; languageCode = &quot;en-us&quot; title = &quot;A Hugo website&quot; theme = &quot;hugo-lithium-theme&quot; [[menu.main]] name = &quot;About&quot; url = &quot;/about/&quot; [[menu.main]] name = &quot;GitHub&quot; url = &quot;https://github.com/rstudio/blogdown&quot; [[menu.main]] name = &quot;Twitter&quot; url = &quot;https://twitter.com/rstudio&quot; Puede cambiar el título de la página web, e.g., title = &quot;Mi propia página web chévere&quot;, y actualizar las URL de GitHub y Twitter. El directorio de contenido (por defecto, content/). Aquí es donde usted escribe los archivos de origen R Markdown o Markdown para sus publicaciones y páginas. Bajo content/ del sitio predeterminado, puede ver about.md y un directoriopost/ que contiene algunas publicaciones. La organización del directorio de contenido depende de usted. Puede tener archivos y directorios arbitrarios allí, según la estructura del sitio web que desee. El directorio de publicación (por defecto, public/). Su sitio web se generará en este directorio, lo que significa que no necesita agregar manualmente ningún archivo a este directorio.8 Por lo general, contiene una gran cantidad de archivos *.html y dependencias como *.css, *.js e imágenes. Puede cargar todo en public/ a cualquier servidor web que pueda publicar sitios web estáticos, y su sitio web estará en funcionamiento. Hay muchas opciones para publicar sitios web estáticos, y hablaremos más sobre ellos en el capítulo ?? si no está familiarizado con la implementación de sitios web. Si está satisfecho con este tema predeterminado, ¡está básicamente listo para comenzar a escribir y publicar su nuevo sitio web! Mostraremos cómo usar otros temas en la sección 1.6. Sin embargo, tenga en cuenta que un tema más complicado y elegante puede requerir que aprenda más sobre todas las tecnologías subyacentes, como el lenguaje de plantillas de Hugo, HTML, CSS y JavaScript. References "],
["rstudio-ide.html", "1.3 RStudio IDE", " 1.3 RStudio IDE Hay algunos complementos básicos de RStudio para facilitar la edición y la vista previa de su sitio web, y puede encontrarlos en el menú “Addins” en la barra de herramientas de RStudio: “Serve Site”: este complemento llama a blogdown::serve_site() para presentar continuamente su sitio web localmente utilizando la tecnología LiveReload, para que pueda ver en vivo el sitio web. Puede seguir editando material para su sitio mientras lo está viendo, pero esta función bloqueará su consola de R de manera predeterminada, lo que significa que no podrá usar su consola de R una vez que inicie este servidor web local. Para desbloquear la consola, haga clic en el signo de stop rojo en la esquina superior derecha de la ventana de la consola. Si prefiere evitar este comportamiento por completo, establezca la opción options(servr.daemon = TRUE), antes de hacer clic en este complemento o llame a la función serve_site(), para que el servidor sea demonizado y no bloquee su consola de R.^ [Hemos oído de casos en los que el servidor demonizado bloquea R en Windows. Si tiene problemas con el servidor daemonizado, existen tres soluciones alternativas, y puede probar una de ellas: (1) instalar el paquete later a través de install.packages(&quot;later&quot;) y volver a iniciar el servidor; (2) use el servidor de Hugo (vea la sección D.2); (3) llame blogdown::serve_site() en una sesión de R separada, y puede obtener una vista previa de su sitio web en su navegador web, pero aún puede editar el sitio web en RStudio.] “New Post”: este complemento proporciona un cuadro de diálogo para que ingrese los metadatos de la publicación de su blog, incluidos el título, el autor, la fecha, etc. Ver la Figura 1.2 para un ejemplo. Este complemento realmente llama a la función blogdown::new_post(), pero hace algunas cosas automáticamente: A medida que escribe el título de la publicación, generará un nombre de archivo para usted, y puede editarlo si no le gusta el generado automáticamente. De hecho, también puede usar este complemento para crear páginas normales en cualquier directorio bajo content/. Por ejemplo, si desea agregar una página de currículum, puede cambiar el nombre del archivo a resume.md del ’post/YYYY-mm-dd-resume.md` predeterminado. Puede seleccionar la fecha desde un widget de calendario proporcionado por Shiny.9 Esto escaneará las categorías y etiquetas de las publicaciones existentes, por lo que cuando quiera ingresar categorías o etiquetas, puede seleccionarlas de los menús desplegables o crear otras nuevas. Después de crear una nueva publicación, se abrirá automáticamente, por lo que puede comenzar a escribir el contenido de inmediato. “Update Metadata”: Este complemento le permite actualizar los metadatos YAML de la publicación abierta actualmente. Ver la Figura @ref(fig: update-meta) para un ejemplo. La principal ventaja de este complemento es que puede seleccionar categorías y etiquetas de los menús desplegables en lugar de tener que recordarlas. FIGURA 1.2: Crear una nueva publicación usando el complemento de RStudio. FIGURA 1.3: Actualizar los metadatos de una publicación existente usando el complemento de RStudio. Con estos complementos, rara vez deberá ejecutar los comandos en R manualmente después de haber configurado su sitio web, ya que todas sus publicaciones se compilarán automáticamente cada vez que cree una nueva publicación o modifique una existente debido a la función LiveReload. Si su versión de RStudio es por lo menos la v1.1.383,10 puede actualmente crear un proyecto de página web directamente desde el menú File -&gt; New Project -&gt; New Directory (vea la Figura 1.4 y 1.5). FIGURA 1.4: Crear un nuevo proyecto de página web en RStudio. FIGURA 1.5: Crear un proyecto de página web basado en blogdown. Si su sitio web se creó utilizando la función blogdown::new_site() en lugar del menú de RStudio por primera vez, puede salir de RStudio y volver a abrir el proyecto. Si accede al menú Tools -&gt; Project Options, su tipo de proyecto debería ser “Website” como lo puede ver en la Figura 1.6. Luego verá un panel en RStudio llamado “Build” y hay un botón “Build Website”. Al hacer clic en este botón, RStudio llamará a blogdown::build_site () para construir el sitio web. Esto generará automáticamente archivos en el directorio public/.11 Si desea compilar el sitio web y publicar los archivos de salida en public/ manualmente, se recomienda reiniciar su sesión de R y hacer clic en este botón “Build Website” antes de publicar el sitio web, en lugar de publicar la carpeta public/ generada de forma continua y automática por blogdown::serve_site(), porque este último llama a blogdown::build_site(local = TRUE), que tiene algunas diferencias sutiles con blogdown::build_site(local = FALSE) (ver la sección D.3 para más detalles). Recomendamos mucho que desmarque la opción “Preview site after building” en las opciones de proyecto de RStudio (Figura 1.6).12 También puede desmarcar la opción “Re-knit current preview when supporting files change”, ya que esta opción no es realmente útil después de llamar a serve_site(). FIGURA 1.6: Opciones de proyecto de RStudio. Shiny es un paquete R para crear aplicaciones web interactivas usando R. Usando este complemento, el widget de calendario le permite ver un calendario interactivo por mes para seleccionar fechas. Este es un uso simple de Shiny, pero puede leer más acerca de las aplicaciones Shiny aquí: https://shiny.rstudio.com.↩ Puede descargar todas las versiones del sitio oficial de RStudio incluyendo la v1.1.383 desde https://www.rstudio.com/products/rstudio/download/.↩ O donde sea que esté ubicado su directorio de publicación. Es public/ de forma predeterminada, pero se puede cambiar especificando publishDir =&quot;myNewDirectory&quot; en el archivo config.toml.↩ En caso de que se pregunte por qué: a menos que haya establecido la opción relativeurls a true en config.toml, requiere un servidor web para obtener una vista previa del sitio local, de lo contrario, incluso si puede ver la página de inicio de su sitio web en RStudio Viewer, la mayoría de los enlaces como los enlaces a archivos CSS y JavaScript son poco probables que funcionen. Cuando RStudio Viewer le muestra la vista previa, en realidad no ejecuta un servidor web.↩ "],
["opciones-globales.html", "1.4 Opciones globales", " 1.4 Opciones globales Dependiendo de sus preferencias personales, puede establecer algunas opciones globales antes de trabajar en su sitio web. Estas opciones se deben configurar usando options(name = value), y las opciones disponibles actualmente se presentan en Table 1.1. TABLA 1.1: Opciones globales que afectan el comportamiento de blogdown. Option name Default Meaning servr.daemon FALSE Si debe usar un servidor demonizado blogdown.author El autor por defecto de nuevas publicaciones blogdown.ext .md Extensión por defecto de nuevas publicaciones blogdown.subdir post Un subdirectorio bajo content/ blogdown.yaml.empty TRUE Preservar campos vacíos en YAML? Le recomendamos que configure estas opciones en su archivo de perfil de inicio de R. Puede consultar la página de ayuda ?Rprofile para más detalles, y aquí hay una introducción simplificada. Un archivo de perfil de inicio es básicamente un script en R que se ejecuta cuando se inicia la sesión de R. Este es un lugar perfecto para establecer opciones globales, por lo que no necesita escribir estas opciones nuevamente cada vez que inicie una nueva sesión en R. Puede usar un archivo de perfil global ~/.Rprofile,13 O un archivo por proyecto .Rprofile en el directorio raíz de su proyecto de RStudio. El primero se aplicará a todas las sesiones de R que inicie, a menos que haya proporcionado el último para anularlo. La forma más fácil de crear un archivo de este tipo es usar file.edit() en RStudio, por ejemplo, file.edit(&#39;~/.Rprofile&#39;) # o file.edit(&#39;.Rprofile&#39;) Supongamos que siempre prefiere el servidor demonizado y quiere que el autor de las nuevas publicaciones sea “John Doe” de manera predeterminada. Puede establecer estas opciones en el archivo de perfil: options(servr.daemon = TRUE, blogdown.author = &#39;John Doe&#39;) Una buena consecuencia de establecer estas opciones es que cuando usa el complemento de RStudio “New post”, los campos “Author”, “Subdirectory” y “Format” se completarán automáticamente, por lo que no tendrá que manipularlos todas las veces a menos que desea cambiar los valores predeterminados (ocasionalmente). R solo lee un archivo de perfil de inicio. Por ejemplo, si tiene un .Rprofile en el directorio actual y un ~/.Rprofile global, solo el anterior se ejecutará cuando R se inicie desde el directorio actual. Esto puede hacer que sea inconveniente para varios autores que colaboran en el mismo proyecto de un sitio web, ya que no puede establecer opciones específicas del autor. En particular, no es posible establecer la opción blogdown.author en un solo .Rprofile, porque esta opción debería ser diferente para diferentes autores. Una solución consiste en establecer opciones comunes en .Rprofile bajo del directorio raíz del proyecto del sitio web, y también ejecutar el ~/.Rprofile global si existe. Las opciones específicas del autor se pueden establecer en el ~/.Rprofile global en la computadora de cada autor. # en el .Rprofile del proyecto de la página web if (file.exists(&#39;~/.Rprofile&#39;)) { base::sys.source(&#39;~/.Rprofile&#39;, envir = environment()) } # luego configure options(blogdown.author = &#39;Your Name&#39;) en ~/.Rprofile La tilde ~ indica el directorio principal en su sistema.↩ "],
["output-format.html", "1.5 R Markdown vs. Markdown", " 1.5 R Markdown vs. Markdown Si no está familiarizado con R Markdown , consulte el Apéndice A para obtener un tutorial rápido. Cuando crea una nueva publicación, debe decidir si desea usar R Markdown o Markdown simple , como puede ver en Figure 1.2. Las principales diferencias son: No puede ejecutar ningún código en R en un documento de Markdown simple, mientras que en un documento de Markdown R, puede incrustar fragmentos de código R (```{r}). Sin embargo, aún puede incrustar código de R en Markdown simple usando la sintaxis para bloques de código delimitados ```r(tenga en cuenta que no hay llaves {}). Tales bloques de código no se ejecutarán y pueden ser adecuados para propósitos de demostración pura. A continuación se muestra un ejemplo de un fragmento de código de R en R Markdown: ```{r cool-plot, fig.width=&#39;80%&#39;, fig.cap=&#39;A cool plot.&#39;} plot(cars, pch = 20) # no es muy chévere ``` Y aquí hay un ejemplo de un bloque de código de R en Markdown simple: ```r 1 + 1 # no ejecutada ``` Una publicación en Markdown simple es ejecutada en HTML a través de Blackfriday (un paquete escrito en lenguaje Go y adoptado por Hugo). Un documento R Markdown se compila a través de los paquetes rmarkdown, bookdown, y Pandoc, lo que significa que puede usar la mayoría de las características de Markdown de Pandoc y extensiones de Markdown para bookdown en blogdown. Si usa R Markdown (Allaire et al. 2018) con blogdown, le recomendamos que lea la documentación de Pandoc y bookdown al menos una vez para conocer todas las características posibles. No repetiremos los detalles en este libro, pero enumeraremos las características brevemente a continuación, que también se muestran en el sitio web de ejemplo: https://blogdown-demo.rbind.io. Formateo en línea: texto en _italica_ / **negrita** y `código en línea`. Elementos en línea: subíndices (e.g., H~2~0) y superíndices (e.g., R^2^); links ([texto](url)) e imágenes ![título](url); notas al pie texto^[nota al pie]. Elementos de nivel bloque: párrafos; encabezados de sección numerados y no numerados; listas ordenadas y no ordenadas; citas en bloque; bloques de código; tablas; reglas horizontales. Expresiones matemáticas y ecuaciones. Teoremas y demostraciones. Bloques de código en R que se pueden usar para producir salida de texto (incluidas tablas) y gráficos. Tenga en cuenta que las ecuaciones, teoremas, tablas y figuras se pueden numerar y referenciadas cruzadamente. Citas y bibliografía. HTML widgets, y aplicaciones en Shiny incrustadas mediante &lt;iframe&gt;. Hay muchas diferencias en la sintaxis entre el Markdown de Blackfriday y el Markdown de Pandoc. Por ejemplo, puede escribir una lista de tareas con Blackfriday, pero no con Pandoc: - [x] Escribir un paquete en R. - [ ] Escribir un libro. - [ ] ... - [ ] Beneficio! Del mismo modo, Blackfriday no admite matemática en LaTeX y Pandoc sí. Hemos agregado el soporte MathJax al tema predeterminado (hugo-lithium-theme en blogdown para compilar matemática en LaTeX en páginas HTML, pero hay una advertencia para las publicaciones simples de Markdown: debe incluir expresiones matemáticas en línea con un par de comillas `$math$`, por ejemplo, `$S_n = \\ um_{i=1}^n X_i$`. Del mismo modo, las expresiones matemáticas del estilo de visualización deben escribirse en `$$math$$`. Para las publicaciones de R Markdown, puede usar $math$ para expresiones matemáticas en línea, y $$math$$ para expresiones de estilo de visualización.14 Si considera que es un dolor tener que recordar las diferencias entre R Markdown y Markdown, una opción conservadora es usar siempre R Markdown, incluso si su documento no contiene ningún fragmento de código en R. Markdown de Pandoc es mucho más rico que Blackfriday, y solo hay un pequeño número de características no disponibles en Pandoc pero presentes en Blackfriday. Las principales desventajas de usar R Markdown son: Puede sacrificar algo de velocidad en la renderización del sitio web, pero esto puede no ser notorio debido a un mecanismo de almacenamiento en caché en blogdown (lea más sobre esto en la sección D.3). Hugo es muy rápido cuando procesa archivos de Markdown simples, y típicamente debería tomar menos de un segundo para renderizar unos cientos de archivos de Markdown. Tendrá algunos archivos HTML intermedios en el directorio fuente de su sitio web, porque blogdown tiene que llamar a rmarkdown para renderizar previamente los archivos *.Rmd *.html. También tendrá carpetas intermedias para las figuras (*_files/) y la memoria caché (*_cache/) si tiene una salida de trazado en fragmentos de código en R o ha habilitado el almacenamiento en cache de knitr. A menos que le importe mucho la “limpieza” del repositorio fuente de su sitio web (especialmente cuando usa una herramienta de control de versiones como GIT), estos archivos intermedios no deberían importar. En este libro, generalmente nos referimos a los archivos .Rmd cuando decimos “Documentos de R Markdown”, que se compilan a .html de forma predeterminada. Sin embargo, hay otro tipo de documento de R Markdown con la extensión de nombre de archivo .Rmarkdown. Dichos documentos de R Markdown se compilan para los documentos Markdown con la extensión .markdown, que serán procesados por Hugo en lugar de por Pandoc. Hay dos limitaciones principales de usar .Rmarkdown en comparación con.Rmd: No puede usar las funciones de reducción solo compatibles con Pandoc, como las citas. Las expresiones matemáticas solo funcionan si ha instalado el paquete xaringan (Xie 2018d) y ha aplicado la solución de JavaScript mencionada en la sección B.3. Los widgets HTML no son compatibles. La principal ventaja de usar .Rmarkdown es que los archivos de salida son más limpios porque son archivos Markdown. Puede ser más fácil para usted leer la salida de sus publicaciones sin mirar las páginas web reales renderizadas. Esto puede ser particularmente útil al revisar los pull requests de GitHub. Tenga en cuenta que las tablas, figuras, ecuaciones y teoremas numerados también son compatibles. No puede usar directamente la sintaxis de Markdown en las leyendas de tabla o figura, pero puede usar referencias de texto como una solución alternativa (consulte la documentación de bookdown). Para cualquier documento de R Markdown (no específico de blogdown), debe especificar un formato de salida. Hay muchos posibles formatos de salida en el paquete rmarkdown (como html_document y pdf_document) y otros paquetes de extensión (tales como tufte::tufte_html y bookdown::gitbook). Por supuesto, el formato de salida para los sitios web debe ser HTML. Hemos proporcionado una función de formato de salida blogdown::html_page en blogdown, y todos los archivos R Markdown se renderizan con este formato. Se basa en el formato de salida bookdown::html_document2, lo que significa que ha heredado muchas características de bookdown además de las características en Pandoc. Por ejemplo, puede numerar y hacer referencias cruzadas de ecuaciones matemáticas, figuras, tablas y teoremas, etc. Consulte el Capítulo 2 del libro bookdown (Xie 2016) para obtener más detalles sobre la sintaxis. Note que el formato de salida bookdown::html_document2 a su vez hereda de rmarkdown::html_document, entonces necesita ver la página de ayuda ?rmarkdown::html_document para todas las opciones posibles para el formato blogdown::html_page. Si desea cambiar los valores predeterminados de las opciones de este formato de salida, puede agregar un campo output a sus metadatos YAML. Por ejemplo, podemos agregar una tabla de contenido a una página, establecer el ancho de la figura en 6 pulgadas y usar el dispositivo svg para los gráficos estableciendo estas opciones en YAML: --- title: &quot;Mi grandiosa publicación&quot; author: &quot;John Doe&quot; date: &quot;2017-02-14&quot; output: blogdown::html_page: toc: true fig_width: 6 dev: &quot;svg&quot; --- Para establecer opciones para blogdown::html_page() globalmente (es decir, aplicar ciertas opciones a todos los archivos Rmd), puede crear un archivo _output.yml en el directorio raíz de su sitio web. Este archivo YAML debe contener el formato de salida directamente (no coloque el formato de salida bajo la opción output), por ejemplo, blogdown::html_page: toc: true fig_width: 6 dev: &quot;svg&quot; Por el momento, no todas las funciones de rmarkdown::html_document son compatibles con blogdown, como df_print, code_folding,code_download, etc. Si su trozo de código tiene salida de gráficos, le recomendamos que evite caracteres especiales como espacios en la etiqueta de fragmentos. Lo ideal es que solo use caracteres alfanuméricos y guiones, por ejemplo, ```{r, my-label} en lugar de ```{r, my label}. No se recomienda cambiar las opciones knitr chunk fig.path o cache.path en R Markdown. Los valores predeterminados de estas opciones funcionan mejor con blogdown. Lea la sección ?? para conocer los motivos técnicos, si lo prefiere. Si está trabajando en una publicación de R Markdown, pero no quiere que blogdown la compile, puede cambiar temporalmente su extensión de nombre de archivo de .Rmd a otra extensión desconocida como .Rmkd. References "],
["otros-temas.html", "1.6 Otros temas", " 1.6 Otros temas En Hugo, los temas controlan toda la apariencia y funcionalidad de su sitio. Entonces, si le importa mucho el aspecto de su sitio web, probablemente pasará bastante tiempo al principio buscando un tema de Hugo que le guste de la colección que figura en http://themes.gohugo.io. Tenga en cuenta que no todos los temas se han probado en blogdown. Si encuentra que un determinado tema no funciona bien con blogdown, puede informar a https://github.com/rstudio/blogdown/issues, e intentaremos investigar el motivo, pero puede ser una cuestión de tiempo aprender y comprender cómo funciona un nuevo tema, por lo que le recomendamos que aprenda más acerca de Hugo por su cuenta antes de preguntar, y también alentamos a los usuarios a ayudarse mutuamente allí. Después de haber encontrado un tema satisfactorio, debe averiguar su nombre de usuario y el nombre del repositorio de GitHub,15 luego instale el tema a través de blogdown::install_theme(), o simplemente cree un nuevo sitio bajo otro directorio nuevo y pase el nombre del repositorio de GitHub al argumento theme de new_site(). Recomendamos que use el segundo enfoque, porque los temas de Hugo podrían ser muy complicados y el uso de cada tema puede ser muy diferente y muy dependiente del config.toml. Si instala un tema con install_theme() en lugar de new_site (), deberá crear manualmente el archivo config.toml en el directorio raíz de su sitio web para que coincida con el tema recién instalado.16 # por ejemplo, cree un sitio nuevo con el tema academic blogdown::new_site(theme = &#39;gcushen/hugo-academic&#39;) Para ahorrarle tiempo, enumeramos algunos temas a continuación que coinciden con nuestro gusto: Temas Simples/mínimos: XMin, Tanka, simple-a, and ghostwriter. Temas sofisticados: hugo-academic (fuertemente recomendado para usuarios de la academia), hugo-tranquilpeak-theme, hugo-creative-portfolio-theme, and hugo-universal-theme. Temas que contienen multimedia: Si está interesado en agregar contenido multimedia a su sitio (como archivos de audio de un podcast), el tema castanet proporciona un excelente marco adaptado para esta aplicación. Un ejemplo de un sitio que usa blogdown con el tema castanet es R-Podcast Si no entiende HTML, CSS o JavaScript, y no tiene experiencia con los temas o plantillas de Hugo, puede tardar unos 10 minutos en comenzar a usar su nuevo sitio web, ya que debe aceptar todo lo que le ofrecen (como el tema predeterminado); Si tiene el conocimiento y la experiencia (y desea personalizar su sitio al máximo), puede tardar varios días en comenzar. Hugo es realmente poderoso. Tenga cuidado con el poder. Otra cosa a tener en cuenta es que cuanto más esfuerzo hagas en un tema complicado, más difícil será cambiar a otros temas en el futuro, porque es posible que haya personalizado muchas cosas que no son fáciles de transferir a otro tema. Por lo tanto, pregúntese seriamente: “¿Me gusta tanto este tema tan elegante que definitivamente no lo cambiaré en los próximos años?”. Si elige cavar un hoyo bastante profundo, algún día no tendrá más remedio que seguir cavando, incluso con lágrimas. — Liyun Chen17 Para la mayoría de los temas, puede encontrar esto navegando al tema de su elección desde http://themes.gohugo.io y luego haciendo clic en Homepage.↩ Una solución alternativa, si usó install_theme() y establece el argumento theme_example en TRUE, entonces puede acceder a un archivo config.toml de ejemplo. En el directorio themes/, vaya al archivo del tema que acaba de descargar y busque exampleSite/config.toml. Este archivo puede copiarse en su directorio raíz (para reemplazar el archivo config.toml de su tema original) o usarse como una plantilla para escribir correctamente un nuevo archivo config.toml para su nuevo tema.↩ Traducido de su weibo Chino: http://weibo.com/1406511850/Dhrb4toHc (no puede ver esta página a menos que haya iniciado sesión).↩ "],
["workflow.html", "1.7 Un flujo de trabajo recomendado", " 1.7 Un flujo de trabajo recomendado Hay muchas maneras de comenzar a construir un sitio web y presentarlo. Debido a la gran cantidad de tecnologías que necesita aprender para comprender completamente cómo funciona un sitio web, nos gustaría recomendar un flujo de trabajo a los principiantes, por lo que es de esperar que no necesiten digerir el resto de este libro. Definitivamente este no es el flujo de trabajo más óptimo, pero requiere que conozca la menor cantidad de detalles técnicos. Para comenzar un nuevo sitio web: Elija cuidadosamente un tema en http://themes.gohugo.io, y encuentre el enlace a su repositorio GitHub, que tiene la forma https://github.com/user/repo. Cree un nuevo proyecto en RStudio y escriba el código blogdown::new_site (theme = 'user/repo') en la consola R, donde user/repo proviene del enlace en el paso 1. Juegue con el nuevo sitio por un tiempo y si no le gusta, puede repetir los pasos anteriores, de lo contrario edite las opciones en config.toml. Si no comprende ciertas opciones, vaya a la documentación del tema, que a menudo es la página README del repositorio de GitHub. No todas las opciones tienen que ser cambiadas. Para editar una página web: Establezca options(servr.daemon = TRUE) a menos que ya lo haya configurado en .Rprofile. Si esta opción no funciona para usted (por ejemplo, bloquea su sesión en R), consulte la sección 1.4 para obtener una solución alternativa. Haga clic en el complemento de RStudio “Serve Site” para obtener una vista previa del sitio en RStudio Viewer. Esto solo debe hacerse una vez cada vez que abra el proyecto RStudio o reinicie su sesión en R. No haga clic en el botón knit en la barra de herramientas de RStudio. Use el complemento “New Post” para crear una nueva publicación o página, luego empiece a escribir el contenido. Use el complemento “Update Metadata” para modificar los metadatos del YAML, si es necesario. Para publicar un sitio web, si no está familiarizado con GIT o GitHub: Reinicie la sesión de R, y ejecute blogdown::hugo_build(). Debería obtener un directorio public/ bajo el directorio raiz de su proyecto. Inicie sesión en https://www.netlify.com (puede usar una cuenta de GitHub, si la tiene). Si esta es la primera vez que publica este sitio web, puede crear un sitio nuevo; de lo contrario, puede actualizar el sitio existente que creó la última vez. Puede arrastrar y soltar la carpeta public/ desde su visor de archivos al área indicada en la página web de Netlify, donde dice “Drag a folder with a static site here”. Espere unos segundos para que Netlify despliegue los archivos y le asignará un subdominio aleatorio de la forma random-word-12345.netlify.com. Puede (y debería) cambiar este subdominio aleatorio a uno más significativo si todavía está disponible. Puede ser mucho más fácil publicar un sitio web si está familiarizado con GIT y GitHub. Recomendamos que cree un nuevo sitio en Netlify desde su repositorio de GitHub que contenga los archivos fuente de su sitio web, para que pueda disfrutar los beneficios de la implementación continua en lugar de cargar manualmente la carpeta public/ cada vez. Con este enfoque, no es necesario ejecutar blogdown::hugo_build() localmente, ya que el sitio web se puede construir en Netlify a través de Hugo. Consulte el capítulo ?? para obtener más información. "],
["hugo.html", "Capítulo 2 Hugo", " Capítulo 2 Hugo En este capítulo, presentaremos brevemente Hugo (https://gohugo.io), el generador de sitios estáticos en el que se basa blogdown. Este capítulo no pretende reemplazar la documentación oficial de Hugo, sino proporcionar una guía para aquellos que recién están comenzando con Hugo. En caso de duda, consulte la documentación oficial de Hugo. "],
["static-sites.html", "2.1 Sitios estáticos y Hugo", " 2.1 Sitios estáticos y Hugo Un sitio estático a menudo consiste en archivos HTML (con dependencias externas opcionales como imágenes y bibliotecas de JavaScript), y el servidor web envía exactamente el mismo contenido al navegador web sin importar quién visita las páginas web. No hay computación dinámica en el servidor cuando se solicita una página. En contraste, un sitio dinámico se basa en un lenguaje del lado del servidor para hacer cierta informática y envía contenido potencialmente diferente dependiendo de las diferentes condiciones. Un lenguaje común es PHP, y un ejemplo típico de un sitio dinámico es un foro web. Por ejemplo, cada usuario tiene una página de perfil, pero generalmente esto no significa que el servidor haya almacenado una página de perfil HTML diferente para cada usuario. En cambio, el servidor obtendrá los datos del usuario de una base de datos y renderizará la página de perfil de forma dinámica. Para un sitio estático, cada URL que visita a menudo tiene un archivo HTML correspondiente almacenado en el servidor, por lo que no es necesario calcular nada antes de presentar el archivo a los visitantes. Esto significa que los sitios estáticos tienden a ser más rápidos en tiempo de respuesta que los sitios dinámicos, y también son mucho más fáciles de implementar, ya que la implementación simplemente significa copiar archivos estáticos a un servidor. Un sitio dinámico a menudo se basa en bases de datos, y tendrá que instalar más paquetes de software para presentar un sitio dinámico. Para obtener más ventajas de los sitios estáticos, lea la introducción en el sitio web de Hugo. Existen muchos generadores de sitios estáticos existentes, incluyendo Hugo, Jekyll, y Hexo, etc. La mayoría de ellos puede construir sitios web de propósito general, pero a menudo se utilizan para construir blogs. Amamos a Hugo por muchas razones, pero hay algunas que se destacan. A diferencia de otros generadores de sitios estáticos, la instalación de Hugo es muy simple porque proporciona un único archivo ejecutable sin dependencias para la mayoría de los sistemas operativos (consulte la sección ??). También se diseñó para procesar cientos de páginas de contenido más rápido que los generadores de sitios estáticos comparables y, según los informes, puede presentar una página en aproximadamente 1 milisegundo. Por último, la comunidad de usuarios de Hugo es muy activa tanto en el foro de discusión de Hugo y en los issues de GitHub. Aunque creemos que Hugo es un fantástico generador de sitios estáticos, en realidad hay una única característica importante que falta: el soporte para R Markdown. Ese es básicamente el objetivo del paquete blogdown.18 Esta función faltante significa que no puede generar resultados fácilmente usando el código de R en sus páginas web, ya que solo puede usar documentos estáticos de Markdown. Además, el motor de Markdown predeterminado de Hugo es “Blackfriday”, que es menos poderoso que Pandoc.19 Hugo usa una estructura especial de archivos y carpetas para crear su sitio web (Figura 2.1). El resto de este capítulo brindará más detalles sobre los siguientes archivos y carpetas: config.toml content/ static/ themes/ layouts/ FIGURA 2.1: Posibles archivos y carpetas creados cuando crea un nuevo sitio usando blogdown. Otra motivación fue una manera más fácil de crear nuevas páginas o publicaciones. Los generadores de sitios estáticos a menudo proporcionan comandos para crear nuevas publicaciones, pero a menudo tiene que abrir y modificar el nuevo archivo creado a mano después de usar estos comandos. Estaba muy frustrado por esto, porque estaba buscando una interfaz gráfica de usuario donde simplemente pudiera completar el título, el autor, la fecha y otra información sobre una página, luego poder comenzar a escribir el contenido de inmediato. Es por eso que proporcioné el complemento de RStudio “New Post” y la función blogdown::new_post(). En los últimos años, lo odié cada vez que estaba a punto de crear una nueva publicación, ya sea a mano o a través de la línea de comandos de Jekyll. Finalmente, me volví adicto a los blogs una vez que terminé el complemento de RStudio.↩ El soporte de Pandoc se ha agregado en un pull request de Hugo: https://github.com/gohugoio/hugo/pull/4060. Sin embargo, creo que el soporte es bastante limitado, y le recomiendo que use el formato R Markdown, porque con el soporte oficial de Pandoc en Hugo, no puede personalizar las opciones de la línea de comandos de Pandoc, la renderización no está en caché (podría ser lento), y no podrá usar ninguna extensión de Markdown del paquete bookdown (como la numeración de los títulos de las figuras).↩ "],
["configuracion.html", "2.2 Configuración", " 2.2 Configuración El primer archivo que puede ver es el archivo configuration o config en su directorio raíz, en el que puede establecer configuraciones globales de su sitio. Puede contener opciones como el título y la descripción de su sitio, así como otras opciones globales como enlaces a sus redes sociales, el menú de navegación y la URL base de su sitio web. Al generar su sitio, Hugo buscará primero un archivo llamado config.toml. Si no puede encontrar uno, continuará buscando config.yaml.20 Como la mayoría de los temas de Hugo contienen sitios de ejemplo que envían archivos config.toml, y el formato TOML (Tom’s Obvious, Minimal Language) parece ser más popular en la comunidad de Hugo, hablaremos principalmente de config.toml aquí. Recomendamos que utilice la sintaxis TOML solo para el archivo de configuración (también puede usar YAML si lo prefiere), y use YAML como el formato de datos para los metadatos de las páginas y publicaciones de R Markdown, porque R Markdown y blogdown son totalmente compatibles solo con YAML.21 Si tiene un sitio web que ya ha utilizado TOML, puede usar blogdown::hugo_convert (unsafe = TRUE) para convertir los datos de TOML a YAML, pero primero asegúrese de hacer una copia de seguridad del sitio web porque sobrescribirá los archivos de Markdown. La documentación de Hugo no utiliza TOML o YAML consistentemente en sus ejemplos, lo que puede ser confuso. Preste mucha atención al formato de configuración al copiar ejemplos en su propio sitio web. 2.2.1 Sintaxis TOML Si no está familiarizado con la sintaxis de TOML, le daremos una breve descripción general y podrá leer la documentación completa para conocer los detalles. TOML se compone de pares clave-valor separados por signos iguales: key = value Cuando desee editar una configuración en el archivo TOML, simplemente cambie el valor. Los valores que son cadenas de caracteres deben estar entre comillas, mientras que los valores booleanos deben estar minúsculos y descubiertos. Por ejemplo, si desea darle a su sitio el título “Mi Sitio Impresionante” y usar URL relativas en lugar de las URL absolutas predeterminadas, puede tener las siguientes entradas en su archivo config.toml. title = &quot;Mi sitio impresionante&quot; relativeURLs = true La mayoría de las variables globales de su sitio web se ingresan en el archivo config.toml exactamente de esta manera. Más adelante en su archivo config, puede observar algunos valores entre paréntesis como este: [social] github = &quot;https://github.com/rstudio/blogdown&quot; twitter = &quot;https://twitter.com/rstudio&quot; Esta es una tabla en el lenguaje TOML y Hugo los usa para completar información en otras páginas dentro de su sitio. Por ejemplo, la tabla anterior rellenará la variable .Site.Social en las plantillas de su sitio (más información sobre esto en la sección ??). Por último, puede encontrar algunos valores en corchetes dobles como este: [[menu.main]] name = &quot;Blog&quot; url = &quot;/blog/&quot; [[menu.main]] name = &quot;Categories&quot; url = &quot;/categories/&quot; [[menu.main]] name = &quot;About&quot; url = &quot;/about/&quot; En TOML, los corchetes dobles se usan para indicar una matriz de tablas. Hugo interpreta esta información como un menú. Si el código anterior se encuentra en un archivo config.toml, el sitio web resultante tendrá enlaces a las páginas Blog, Categorías y Acerca de en el menú principal del sitio. La ubicación y el estilo de ese menú se especifican en otra parte, pero aquí se definen los nombres de las opciones de cada menú y los enlaces a cada sección. El archivo config.toml es diferente para cada tema. Asegúrese de que cuando elija un tema, lea su documentación a fondo para comprender lo que hace cada una de las opciones de configuración (más sobre los temas en la sección 2.4). 2.2.2 Opciones Todas las opciones incorporadas que puede establecer para Hugo se enumeran en https://gohugo.io/overview/configuration/. Puede cambiar cualquiera de estas opciones, excepto contentDir, que está codificado en content en blogdown. Nuestra recomendación general es que será mejor que no modifique los valores predeterminados a menos que comprenda las consecuencias. Enumeramos algunas opciones que pueden ser de su interés: baseURL: Normalmente tiene que cambiar el valor de esta opción a la URL base de su sitio web. Algunos temas de Hugo pueden tenerlo configurado para http://replace-this-with-your-hugo-site.com/ o http://www.example.com/ en sus sitios de ejemplo, pero asegúrese de reemplazarlos con su propia URL (consulte el capítulo ?? y el apéndice C para obtener más información sobre la publicación de sitios web y la obtención de nombres de dominio). Tenga en cuenta que esta opción puede ser una URL con un subtrayecto, si su sitio web se publicará en una subruta de un nombre de dominio, e.g., http://www.example.com/docs/. enableEmoji: Puede configurarlo en true para que pueda usar Emoticones Emoji como :smile: en Markdown. permalinks: Reglas para generar enlaces permanentes de sus páginas. Por defecto, Hugo usa nombres de archivos completos bajo content/ para generar links, e.g., content/about.md será renderizado a public/about/index.html, y content/post/2015-07-23-foo.md será renderizado a public/post/2015-07-23-foo/index.html, entonces los enlaces reales son /about/ y /post/2015-07-23-foo/ en el sitio web. Aunque no es necesario establecer reglas personalizadas para enlaces permanentes, es común ver enlaces de la forma /YYYY/mm/dd/post-title/. Hugo le permite usar varias piezas de información sobre un archivo fuente para generar un enlace, como la fecha (año, mes y día), título y nombre de archivo, etc. El enlace puede ser independiente del nombre del archivo. Por ejemplo, puede pedirle a Hugo que presente páginas bajo content/post/ usando la fecha y el título de sus enlaces: [permalinks] post = &quot;/:year/:month/:day/:title/&quot; Personalmente, le recomiendo que use la variable :slug22 En lugar de :títle: [permalinks] post = &quot;/:year/:month/:day/:slug/&quot; Esto se debe a que el título de su publicación puede cambiar, y es probable que no desee que el enlace a la publicación cambie; de lo contrario, debe redirigir el enlace anterior al nuevo enlace, y habrá otros tipos de problemas, como los comentarios de Disqus. La variable :slug vuelve a :title si un campo llamado slug no está establecido en los metadatos YAML de la publicación. Puede establecer un slug fijo para que el enlace a la publicación siempre sea fijo y tendrá la libertad de actualizar el título de su publicación. Puede encontrar una lista de todas las posibles variables que usted puede usar en la opción permalinks en https://gohugo.io/extras/permalinks/. publishDir: El directorio bajo el cual quiere generar el sitio web. theme: El nombre del directorio de Hugo bajo themes/. ignoreFiles: Una lista de patrones de archivo (expresiones regulares) para Hugo con el fin de que ignore ciertos archivos cuando se construye el sitio. Recomiendo que especifique al menos estos patrones [&quot;\\\\.Rmd$&quot;, &quot;\\\\.Rmarkdown$&quot;, &quot;_files$&quot;, &quot;_cache$&quot;]. Debería ignorar los archivos .Rmd porque blogdown los compilará a .html, y le basta a Hugo usar los archivos .html. No hay necesidad de que Hugo construya archivos .Rmd, y actualmente Hugo no sabe cómo. Los directorios con sufijos _files y _cache deberían ser ignorados porque contienen archivos auxiliares una vez que un archivo Rmd se compila, y blogdown los almacenará. Hugo no los debería copiar de nuevo al directorio public/. uglyURLs: Por defecto, Hugo genera URLs “limpias”. Esto puede ser un poco sorprendente y requiere que comprenda cómo funcionan las URL cuando su buscador obtiene una página de un servidor. Básicamente, Hugo genera foo/index.html para foo.md de forma predeterminada en lugar de foo.html, porque el primero le permite visitar la página a través de la URL limpia foo/ sin index.html. La mayoría de los servidores web entienden solicitudes como http://www.example.com/foo/ y presentan index.html bajo foo/. Si prefiere el mapeo estricto de *.md a *.html, puede habilitar las URL “feas” configurando uglyURLs en true. hasCJKLanguage: Si su sitio web se encuentra principalmente en CJK (chino, coreano y japonés), le recomiendo que configure esta opción en true, para que el resumen automático y el recuento de palabras de Hugo funcionen mejor. Además de las opciones incorporadas de Hugo, puede establecer otras opciones arbitrarias en config.toml. Por ejemplo, es muy común ver una opción llamada params, que se usa ampliamente en muchos temas de Hugo. Cuando vea una variable .Site.Params.FOO en un tema de Hugo, significa una opción FOO que se establece bajo [params] en config.toml, por ejemplo, .Site.Params.author es Frida Gomam con el siguiente archivo de configuración: [params] author = &quot;Frida Gomam&quot; dateFormat = &quot;2006/01/02&quot; El objetivo de todas estas opciones es evitar cualquier problema de codificación en los temas de Hugo, de modo que los usuarios puedan editar fácilmente un único archivo de configuración para aplicar el tema a sus sitios web, en lugar de pasar por muchos archivos HTML y realizar cambios uno por uno. Hugo también admite config.json, pero blogdown no lo admite, por lo que no recomendamos que lo use.↩ TOML tiene sus ventajas, pero creo que no son significativas en el contexto de los sitios web de Hugo. Es un dolor tener que conocer otro idioma, TOML, cuando YAML significa “Yet Another Markup Language”. No estoy seguro de si el cómic XKCD se aplica en este caso: https://xkcd.com/927/.↩ Una slug es simplemente una cadena de caracteres que puede usar para identificar una publicación específica. Una slug no cambiará, incluso si el título cambia. Por ejemplo, si decide cambiar el título de su publicación de “Me encanta el blogdown” a “Por qué blogdown es el mejor paquete de la historia” y usó el título de la publicación en la URL, sus enlaces anteriores ahora se romperán. Si, en cambio, especifica la URL a través de un slug (algo así como “blogdown-love”), puede cambiar el título tantas veces como quiera y no terminará con enlaces rotos.↩ "],
["contenido.html", "2.3 Contenido", " 2.3 Contenido La estructura del directorio content/ puede ser arbitraria. Una estructura común es que hay algunas páginas estáticas bajo la raíz de content/, y un subdirectorio post/ que contiene publicaciones de blog: ├── _index.md ├── about.md ├── vitae.md ├── post/ │ ├── 2017-01-01-foo.md │ ├── 2017-01-02-bar.md │ └── ... └── ... 2.3.1 Metadatos YAML Cada página debe comenzar con los metadatos YAML que especifican información como el título, la fecha, el autor, las categorías, las etiquetas, etc. Según el tema específico de Hugo y las plantillas que use, algunos de estos campos pueden ser opcionales. Entre todos los campos de YAML, queremos llamar su atención sobre estos: draft: Puede marcar un documento como borrador configurando draft: true en sus metadatos YAML. Los borradores de mensajes no se mostrarán si el sitio se compila mediante blogdown::build_site() o blogdown::hugo_build (), pero se presentarán en el modo de vista previa local (consulte la sección D.3) publishdate: Puede especificar una fecha futura para publicar un post. Al igual que en las publicaciones preliminares, las publicaciones futuras solo se presentan en el modo de vista previa local. weight: Este campo puede tomar un valor numérico para indicarle a Hugo el orden de las páginas al ordenarlas ; por ejemplo, cuando genera una lista de todas las páginas debajo de un directorio y dos publicaciones tienen la misma fecha, puede asignar diferentes ponderaciones para obtener el orden deseado en la lista. slug: Una cadena de caracteres como la cola de la URL. Es particularmente útil cuando define reglas personalizadas para URL permanentes (vea la sección 2.2.2). 2.3.2 Cuerpo Como mencionamos en la sección @ref(formato de salida), su publicación puede escribirse en R o Markdown. Tenga cuidado con las diferencias de sintaxis entre los dos formatos cuando escribe el cuerpo de una publicación. 2.3.3 Código corto Además de todas las características de Markdown, Hugo proporciona una característica útil llamada “códigos abreviados”. Puede usar un shortcode en el cuerpo de su publicación. Cuando Hugo presenta la publicación, puede generar automáticamente un fragmento de HTML basado en los parámetros que pasa al código corto. Esto es conveniente porque no tiene que escribir o insertar una gran cantidad de código HTML en su publicación. Por ejemplo, Hugo tiene un código abreviado incorporado para incrustar tarjetas de Twitter. Normalmente, así es como inserta una tarjeta de Twitter (Figura @ref(fig: jtleek-tweet)) en una página: &lt;blockquote class=&quot;twitter-tweet&quot;&gt; &lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;Anyone know of an R package for interfacing with Alexa Skills? &lt;a href=&quot;https://twitter.com/thosjleeper&quot;&gt;@thosjleeper&lt;/a&gt; &lt;a href=&quot;https://twitter.com/xieyihui&quot;&gt;@xieyihui&lt;/a&gt; &lt;a href=&quot;https://twitter.com/drob&quot;&gt;@drob&lt;/a&gt; &lt;a href=&quot;https://twitter.com/JennyBryan&quot;&gt;@JennyBryan&lt;/a&gt; &lt;a href=&quot;https://twitter.com/HoloMarkeD&quot;&gt;@HoloMarkeD&lt;/a&gt; ? &lt;/p&gt; &amp;mdash; Jeff Leek (@jtleek) &lt;a href=&quot;https://twitter.com/jtleek/status/852205086956818432&quot;&gt; April 12, 2017 &lt;/a&gt; &lt;/blockquote&gt; &lt;script async src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt; &lt;/script&gt; FIGURA 2.2: A tweet by Jeff Leek. Si usa el código abreviado, todo lo que necesita en el documento fuente de reducción es: {{&lt; tweet 852205086956818432 &gt;}} Básicamente, solo necesita pasar el ID del tweet a un código corto llamado tweet. Hugo buscará el tweet automáticamente y renderizará el fragmento de HTML por usted. Para obtener más información sobre los códigos abreviados, consulte https://gohugo.io/extras/shortcodes/. Se supone que los códigos cortos funcionan solo en documentos de Markdown. Para usar códigos abreviados en R Markdown en lugar de Markdown simple, debe llamar a la función blogdown::shortcode(), e.g., ```{r echo=FALSE} blogdown::shortcode(&#39;tweet&#39;, &#39;852205086956818432&#39;) ``` "],
["temas.html", "2.4 Temas", " 2.4 Temas Un tema de Hugo es una colección de plantillas y archivos opcionales del sitio web, como archivos CSS y JavaScript. En pocas palabras, un tema define el aspecto de su sitio web después de que su contenido fuente se presente a través de las plantillas. Hugo ha proporcionado una gran cantidad de temas aportados por los usuarios en https://themes.gohugo.io. A menos que sea un diseñador web experimentado, es mejor que comience desde un tema existente aquí. La calidad y la complejidad de estos temas varían mucho, y debe elegir uno con precaución. Por ejemplo, puede ver el número de estrellas de un repositorio de temas en GitHub, así como si el repositorio todavía está relativamente activo. No recomendamos utilizar un tema que no se haya actualizado durante más de un año. En esta sección, explicaremos cómo funciona el tema predeterminado en blogdown, que también puede brindarle algunas ideas sobre cómo comenzar con otros temas. 2.4.1 El tema por defecto El tema predeterminado en blogdown, hugo-lithium-theme, está alojado en GitHub en https://github.com/yihui/hugo-lithium-theme. Fue escrito originalmente por Jonathan Rutheiser, y he realizado varios cambios en él. Este tema es adecuado para quienes prefieren estilos mínimos y desean crear un sitio web con algunas páginas y algunas publicaciones en el blog. Normalmente, un repositorio de temas en GitHub tiene un archivo README, que también sirve como la documentación del tema. Después de leerlo, el siguiente archivo para buscar es config.toml en el directorio exampleSite, que contiene configuraciones de muestra para un sitio web basado en este tema. Si un tema no tiene un archivo README oexampleSite, probablemente no debería usarlo. El config.toml del tema hugo-lithium-theme contiene las siguientes opciones: baseurl = &quot;/&quot; relativeurls = false languageCode = &quot;en-us&quot; title = &quot;A Hugo website&quot; theme = &quot;hugo-lithium-theme&quot; googleAnalytics = &quot;&quot; disqusShortname = &quot;&quot; ignoreFiles = [&quot;\\\\.Rmd$&quot;, &quot;\\\\.Rmarkdown&quot;, &quot;_files$&quot;, &quot;_cache$&quot;] [permalinks] post = &quot;/:year/:month/:day/:slug/&quot; [[menu.main]] name = &quot;About&quot; url = &quot;/about/&quot; [[menu.main]] name = &quot;GitHub&quot; url = &quot;https://github.com/rstudio/blogdown&quot; [[menu.main]] name = &quot;Twitter&quot; url = &quot;https://twitter.com/rstudio&quot; [params] description = &quot;A website built through Hugo and blogdown.&quot; highlightjsVersion = &quot;9.11.0&quot; highlightjsCDN = &quot;//cdn.bootcss.com&quot; highlightjsLang = [&quot;r&quot;, &quot;yaml&quot;] highlightjsTheme = &quot;github&quot; MathJaxCDN = &quot;//cdn.bootcss.com&quot; MathJaxVersion = &quot;2.7.1&quot; [params.logo] url = &quot;logo.png&quot; width = 50 height = 50 alt = &quot;Logo&quot; Algunas de estas opciones pueden ser obvias para comprender, y algunas pueden necesitar explicaciones: baseurl: Puede configurar esta opción después, después de tener un nombre de dominio para su sitio web. No olvide la barra inclinada. relativeurls: Esto es opcional. Puede configurarlo como true solo si tiene la intención de ver su sitio web localmente a través de su visor de archivos, por ejemplo, hacer doble clic en un archivo HTML y verlo en su navegador. Esta opción tiene como valor predeterminado false en Hugo, y significa que su sitio web debe ser visto a través de un servidor web, por ejemplo, blogdown::serve_site() ha proporcionado un servidor web local, por lo que puede obtener una vista previa localmente cuando relativeurls = false. title: El título de su sitio web. Típicamente esto se muestra en la barra de título del buscador web o sobre una pestaña de página. theme: El nombre del directorio del tema. Debe tener mucho cuidado al cambiar los temas, porque un tema puede ser drásticamente diferente de otro tema en términos de configuraciones. Es muy posible que un tema diferente no funcione con su config.toml actual. De nuevo, debe leer la documentación de un tema para saber qué opciones son compatibles o requeridas. googleAnalytics: El ID de seguimiento de Google Analytics (por ejemplo, UA-000000-2). Puede inscribirse en https://analytics.google.com para obtener un IDde seguimiento. disqusShortname: El ID de Disqus que creó durante el proceso de configuración de la cuenta en https://disqus.com. Esto es necesario para habilitar los comentarios en su sitio.23 Tenga en cuenta que debe configurar un baseurl funcional y publicar su sitio web antes de que los comentarios de Disqus pueda funcionar. ignoreFiles y permalinks: Estas opciones han sido explicadas en la sección 2.2.2. menu: Esta lista de opciones especifica el texto y la URL de los elementos del menú en la parte superior. Ver la figura 1.1 para una página de muestra. Puede cambiar o agregar más elementos de menú. Si desea ordenar los artículos, puede asignar un peso a cada artículo, e.g., [[menu.main]] name = &quot;Home&quot; url = &quot;/&quot; weight = 1 [[menu.main]] name = &quot;About&quot; url = &quot;/about/&quot; weight = 2 [[menu.main]] name = &quot;GitHub&quot; url = &quot;https://github.com/rstudio/blogdown&quot; weight = 3 [[menu.main]] name = &quot;CV&quot; url = &quot;/vitae/&quot; weight = 4 [[menu.main]] name = &quot;Twitter&quot; url = &quot;https://twitter.com/rstudio&quot; weight = 5 En el ejemplo anterior, agregué un elemento de menú CV con la URL /vitae/, y se supone que hay un archivo fuente correspondiente vitae.md debajo del directorio content/ para generar la página /vitae/index.html, por lo que el enlace realmente funcionará. params: Diversos parámetros del tema. description: Una breve descripción de su sitio web. No es visible en las páginas web (solo puede verlo desde la fuente HTML), pero debe dar a los motores de búsqueda una pista sobre su sitio web. highlightjs*: Estas opciones se usan para configurar las librerías de JavaScript highlight.js para resaltar la sintaxis de los bloques de código sobre las páginas web. Puede cambiar la versión (e.g., 9.12.0), el hosto CND (e.g., usando cdnjs: //cdnjs.cloudflare.com/ajax/libs), agregar más lenguajes (e.g., [&quot;r&quot;, &quot;yaml&quot;, &quot;tex&quot;]), y cambiar el tema (e.g., atom-one-light). Vea https://highlightjs.org/static/demo/ para todos los lenguajes y temas que highlight.js soporta. MathJax*: La librería de JavaScript MathJax puede renderizar expresiones matemáticas en LaTeX sobre páginas web. De la misma forma que highlightjsCDN, puede especificar el host CDN de MathJax, e.g., //cdnjs.cloudflare.com/ajax/libs, y puede especificar la versión de MathJax. logo: Una lista de opciones para definir el logo del sitio web. Por defecto, la imagen logo.png bajo el directorio static/ se usa. Si quiere ser un desarrollador de temas y comprender completamente todos los detalles técnicos sobre estas opciones, debe comprender las plantillas de Hugo, que presentaremos en la sección 2.5. Como mencionamos en la sección @ref(sitios estáticos), blogdown genera contenido estático e inmutable. Para agregar algo dinámico y siempre cambiante (como la posibilidad de que sus seguidores dejen comentarios), debe incorporar un sistema de comentarios externo como Disqus.↩ "],
["plantillas.html", "2.5 Plantillas", " 2.5 Plantillas Un tema de Hugo consta de dos componentes principales: plantillas y archivos web. El primero es esencial y le dice a Hugo cómo presentar una página.24 El último es opcional pero también importante. Por lo general, consta de archivos CSS y JavaScript, así como otros recursos, como imágenes y videos. Estos activos determinan la apariencia y la funcionalidad de su sitio web, y algunos pueden estar integrados en el contenido de sus páginas web. Puede obtener más información sobre las plantillas de Hugo en la documentación oficial (https://gohugo.io/templates/overview/). Hay muchos tipos diferentes de plantillas. Para que le resulte más fácil dominar las ideas clave, creé un tema de Hugo muy mínimo, que cubre la mayoría de las funcionalidades que un usuario promedio puede necesitar, pero el número total de líneas es de solo 150, por lo que podemos hablar de todas las fuentes código de este tema en la siguiente subsección. 2.5.1 Un pequeño ejemplo XMin es un tema de Hugo. Lo escribí desde cero en aproximadamente 12 horas. Aproximadamente media hora se gastó en plantillas, se dedicaron 3,5 horas a modificar los estilos CSS y se gastaron 8 horas en la documentación (https://xmin.yihui.name). Creo que este puede ser un caso representativo de cuánto tiempo pasaría en cada parte cuando diseñe un tema. Está, quizás, en nuestra naturaleza pasar mucho más tiempo en cosas cosméticas como CSS que en cosas esenciales como plantillas. Mientras que la codificación es, a menudo, más fácil que la documentación. Mostraremos el código fuente del tema XMin. Debido a que el tema puede actualizarse ocasionalmente en el futuro, puede seguir este enlace para obtener una versión fija de la que hablaremos en esta sección: https://github.com/yihui/hugo-xmin/tree/4bb305. A continuación se muestra una vista en árbol de todos los archivos y directorios del tema: hugo-xmin/ ├── LICENSE.md ├── README.md ├── archetypes │ └── default.md ├── layouts │ ├── 404.html │ ├── _default │ │ ├── list.html │ │ ├── single.html │ │ └── terms.html │ └── partials │ ├── foot_custom.html │ ├── footer.html │ ├── head_custom.html │ └── header.html ├── static │ └── css │ ├── fonts.css │ └── style.css └── exampleSite ├── config.toml ├── content │ ├── _index.md │ ├── about.md │ ├── note │ │ ├── 2017-06-13-a-quick-note.md │ │ └── 2017-06-14-another-note.md │ └── post │ ├── 2015-07-23-lorem-ipsum.md │ └── 2016-02-14-hello-markdown.md ├── layouts │ └── partials │ └── foot_custom.html └── public └── ... LICENSE.md y README.md no son componentes necesarios de un tema, pero definitivamente debe elegir una licencia para su código fuente para que otras personas puedan usar su código correctamente, y un README puede ser la breve documentación de su software. El archivo archetypes/default.md define la plantilla predeterminada en función de qué usuarios pueden crear nuevas publicaciones. En este tema, default.md solo proporcionaba metadatos YAML vacíos: --- --- Los directorios más importantes de un tema son layouts/ y static/. Las plantillas HTML se almacenan en layouts/, y los archivos se almacenan en static/. Para comprender layouts/, debe conocer algunos conceptos básicos sobre HTML (consulte la sección B.1) porque las plantillas en este directorio son, en su mayoría, documentos o fragmentos HTML. Hay muchos tipos posibles de subdirectorios en layouts/, pero solo vamos a introducir dos aquí: _default/ y partials/. El directorio _default/ es donde almacena las plantillas predeterminadas para sus páginas web. En el tema XMin, tenemos tres plantillas: single.html,list.html, y terms.html. single.html es una plantilla para presentar páginas individuales. Una sola página básicamente corresponde a un documento de Markdown bajo content/, y contiene tanto los metadatos (YAML) como el contenido. Por lo general, queremos mostrar el título de la página, el autor, la fecha y el contenido. A continuación se muestra el código fuente de single.html de XMin: {{ partial &quot;header.html&quot; . }} &lt;div class=&quot;article-meta&quot;&gt; &lt;h1&gt;&lt;span class=&quot;title&quot;&gt;{{ .Title }}&lt;/span&gt;&lt;/h1&gt; {{ with .Params.author }} &lt;h2 class=&quot;author&quot;&gt;{{ . }}&lt;/h2&gt; {{ end }} {{ if .Params.date }} &lt;h2 class=&quot;date&quot;&gt;{{ .Date.Format &quot;2006/01/02&quot; }}&lt;/h2&gt; {{ end }} &lt;/div&gt; &lt;main&gt; {{ .Content }} &lt;/main&gt; {{ partial &quot;footer.html&quot; . }} Verá muchos pares de corchetes {{}}, y así es como se programan las plantillas usando las variables y funciones de Hugo. La plantilla comienza con una plantilla parcial header.html, para la cual verá el código fuente pronto. Por ahora, puede imaginarlo como todas las etiquetas HTML antes del cuerpo de su página (e.g., &lt;html&gt;&lt;head&gt;). Ls plantillas parciales se usan, principalmente, para reutilizar código HTML. Por ejemplo, todas las páginas HTML pueden compartir tags muy similares &lt;head&gt;&lt;/head&gt;, y puede factorizar las partes comunes en plantillas parciales. Los metadatos de una página se incluyen en un elemento &lt;div&gt; con la clase article-meta. Recomendamos que asigne clases a elementos HTML al diseñar plantillas, de modo que sea más fácil aplicar estilos CSS a estos elementos usando nombres de clase. En una plantilla, tiene acceso a muchas variables proporcionadas por Hugo, por ejemplo, la variable .Title almacena el valor del título de la página, y escribimos el título en &lt;span&gt; en un encabezado de primer nivel &lt;h1&gt;. De forma similar, el autor y la fecha se escriben en &lt;h2&gt;, pero solo si se proporcionan en los metadatos YAML. La sintaxis {{ con FOO }}{{ . }}{{ end }} es una abreviatura de {{si FOO }}{{ FOO }}{{ end }}, es decir, le ahorra el esfuerzo de digitar la expresión FOO dos veces usando {{ . }}. El método .Format se puede aplicar a un objeto de fecha, y en este tema, formateamos las fechas en el formato YYYY/mm/dd (2006/01/02 es la forma de especificar el formato en Go) . Luego mostramos el contenido de una página, que se almacena en la variable .Content. El contenido está envuelto en una etiqueta HTML semántica &lt;main&gt;. La plantilla finaliza después de incluir otra plantilla parcial footer.html (código fuente que se mostrará en breve). Para que sea más fácil de entender cómo funciona una plantilla, mostramos un mínimo ejemplo de publicación a continuación: --- title: Hello World author: Frida Gomam date: 2017-06-19 --- A single paragraph. Con la plantilla single.html, se convertirá en una página HTML con un código fuente que se parece más o menos a esto (con el encabezado y el pie de página omitidos): &lt;div class=&quot;article-meta&quot;&gt; &lt;h1&gt;&lt;span class=&quot;title&quot;&gt;Hello World&lt;/span&gt;&lt;/h1&gt; &lt;h2 class=&quot;author&quot;&gt;Frida Gomam&lt;/h2&gt; &lt;h2 class=&quot;date&quot;&gt;2017/06/19&lt;/h2&gt; &lt;/div&gt; &lt;main&gt; &lt;p&gt;A single paragraph.&lt;/p&gt; &lt;/main&gt; Para un ejemplo completo de una página sencilla, puede ver https://xmin.yihui.name/about/. list.html es la plantilla para generar listas de páginas, como una lista de publicaciones de blog, o una lista de páginas dentro de una categoría o etiqueta. Aquí está su código fuente: {{ partial &quot;header.html&quot; . }} {{if not .IsHome }} &lt;h1&gt;{{ .Title }}&lt;/h1&gt; {{ end }} {{ .Content }} &lt;ul&gt; {{ range (where .Data.Pages &quot;Section&quot; &quot;!=&quot; &quot;&quot;) }} &lt;li&gt; &lt;span class=&quot;date&quot;&gt;{{ .Date.Format &quot;2006/01/02&quot; }}&lt;/span&gt; &lt;a href=&quot;{{ .URL }}&quot;&gt;{{ .Title }}&lt;/a&gt; &lt;/li&gt; {{ end }} &lt;/ul&gt; {{ partial &quot;footer.html&quot; . }} Nuevamente, usa dos plantillas parciales header.html y footer.html. La expresión {{if not .IsHome}} significa, si esta lista no es la página de inicio, muestre el título de la página. Esto es porque no quiero mostrar el título en la página de inicio. Es solo mi preferencia personal. Sin duda, puede mostrar el título en &lt;h1&gt; en la página de inicio, si lo desea. El {{.Content}} muestra el contenido de la lista. Tenga en cuenta que típicamente .Content está vacío, lo que puede sorprender. Esto se debe a que una página de lista no se genera a partir de un archivo de marca de origen de forma predeterminada. Como sea, hay una excepción. Cuando se escribe un archivo Markdown especial _index.md en un directorio correspondiente al nombre de la lista, el .Contenido de la lista será el contenido de este archivo Markdown. Por ejemplo, puede definir el contenido de su página de inicio en content/_index.md, y el contenido de la página de la lista de publicaciones en content/post/_index.md. A continuación, generamos la lista utilizando un bucle (range) a través de todas las páginas filtradas por la condición de que la sección de una página no debe estar vacía. “Section” en Hugo significa el nombre del subdirectorio de primer nivel bajo content/. Por ejemplo, la sección de content/post/foo.md es post. Por lo tanto, el filtro significa que enumeraremos todas las páginas bajo subdirectorios de content/. Esto excluirá las páginas debajo del directorio raíz content/, como content/about.md. Tenga en cuenta que la variable .Data es dinámica y su valor cambia de acuerdo con la lista específica que desea generar. Por ejemplo, la página de la lista https://xmin.yihui.name/post/ solo contiene páginas bajo content/post/, y https://xmin.yihui.name/note/ solo contiene páginas bajo content/note/. Estas páginas de lista son generadas automáticamente por Hugo, y no necesita pasar explícitamente por las secciones publicación y nota. Es decir, una sola plantilla list.html generará múltiples listas de páginas según las secciones y los términos de taxonomía (por ejemplo, categories y tags) que tenga en su sitio web. Los elementos de la lista están representados por las etiquetas HTML &lt;li&gt; en &lt;ul&gt;. Cada elemento consta de la fecha, el enlace y el título de una página. Puede ver https://xmin.yihui.name/post/ para obtener un ejemplo completo de una página de lista. terms.html es la plantilla para la página de inicio de los términos de la taxonomía. Por ejemplo, puede usarlo para generar la lista completa de categorías o etiquetas. El código fuente está a continuación: {{ partial &quot;header.html&quot; . }} &lt;h1&gt;{{ .Title }}&lt;/h1&gt; &lt;ul class=&quot;terms&quot;&gt; {{ range $key, $value := .Data.Terms }} &lt;li&gt; &lt;a href=&#39;{{ (print &quot;/&quot; $.Data.Plural &quot;/&quot; $key) | relURL }}&#39;&gt; {{ $key }} &lt;/a&gt; ({{ len $value }}) &lt;/li&gt; {{ end }} &lt;/ul&gt; {{ partial &quot;footer.html&quot; . }} Similar a list.html, también usa un bucle. La variable .Data.Terms almacena todos los términos bajo una taxonomía, por ejemplo, todos los nombres de categorías. Puede considerarlo como una lista con nombre en R (llamado ‘map’ en Go), cuyos nombres son los términos y los valores son listas de páginas. La variable $key denota el término y $value denota la lista de páginas asociadas con este término. Lo que presentamos en cada &lt;li&gt; es un enlace al término página, así como el recuento de publicaciones que utilizan este término (len es una función Go que devuelve la longitud de un objeto). Hugo representa automáticamente todas las páginas de taxonomía, y los nombres de ruta son las formas plurales de las taxonomías, por ejemplo, https://xmin.yihui.name/categories/ y https://xmin.yihui.name/tags/. Ese es el significado de .Data.Plural. El $ inicial es obligatorio porque estamos dentro de un bucle y necesitamos acceder a variables del alcance externo. El enlace del término se pasa a la función Hugo relURL a través de una conector | para hacerlo relativo, lo cual es una buena práctica porque los enlaces relativos son más portátiles (independientemente del nombre de dominio). El directorio parials/ es el lugar para poner los fragmentos HTML para ser reutilizados por otras plantillas a través de la función partial. Tenemos cuatro plantillas parciales bajo este directorio: header.html define la etiqueta &lt;head&gt; y el menú de navegación en la etiqueta &lt;nav&gt;. &lt;!DOCTYPE html&gt; &lt;html lang=&quot;{{ .Site.LanguageCode }}&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;{{ .Title }} | {{ .Site.Title }}&lt;/title&gt; &lt;link href=&#39;{{ &quot;/css/style.css&quot; | relURL }}&#39; rel=&quot;stylesheet&quot; /&gt; &lt;link href=&#39;{{ &quot;/css/fonts.css&quot; | relURL }}&#39; rel=&quot;stylesheet&quot; /&gt; {{ partial &quot;head_custom.html&quot; . }} &lt;/head&gt; &lt;body&gt; &lt;nav&gt; &lt;ul class=&quot;menu&quot;&gt; {{ range .Site.Menus.main }} &lt;li&gt;&lt;a href=&quot;{{ .URL | relURL }}&quot;&gt;{{ .Name }}&lt;/a&gt;&lt;/li&gt; {{ end }} &lt;/ul&gt; &lt;hr/&gt; &lt;/nav&gt; El área &lt;head&gt; debe ser fácil de entender si está familiarizado con HTML. Tenga en cuenta que también incluimos una plantilla parcial head_custom.html, que está vacía en este tema, pero hará que sea mucho más fácil para los usuarios agregar código personalizado a &lt;head&gt; sin reescribir toda la plantilla. Ver la sección @ref(layouts personalizados) para más detalles. El menú de navegación es esencialmente una lista, y cada elemento de la lista se lee de la variable .Site.Menus.main. Esto significa que los usuarios pueden definir el menú en config.toml, e.g., [[menu.main]] name = &quot;Home&quot; url = &quot;/&quot; [[menu.main]] name = &quot;About&quot; url = &quot;/about/&quot; Esto generará un menú como: &lt;ul class=&quot;menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/about/&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; Hugo tiene un poderoso sistema de menú, y solo usamos el tipo más simple de menú en este tema. Si está interesado en más funciones como menús anidados, consulte la documentación completa en http://gohugo.io/extras/menus/. footer.html define el área footer de una página y cierra el documento HTML: &lt;footer&gt; {{ partial &quot;foot_custom.html&quot; . }} {{ with .Site.Params.footer }} &lt;hr/&gt; {{ . | markdownify }} {{ end }} &lt;/footer&gt; &lt;/body&gt; &lt;/html&gt; El propósito de la plantilla parcial foot_custom.html es el mismo que head_custom.html; es decir, para permitir que el usuario agregue código personalizado al &lt;footer&gt; sin volver a escribir la plantilla completa. Por último, usamos la variable .Site.Params.footer para generar un pie de página. Tenga en cuenta que utilizamos la función with nuevamente. Recuerde que la sintaxis {{with .Site.Params.footer}}{{ . }}{{ end }} es una abreviatura de {{if .Site.Params.footer }}{{.Site.Params.footer }}{{ end }}. Esta sintaxis le evita escribir dos veces la expresión .Site.Params.footer usando {{ . }} como un marcador de posición para la variable footer, que se define como un parámetro de sitio en nuestro archivo config.toml. La función adicional markdownify puede convertir Markdown a HTML (es decir, {{ . | markdownify}}. En conjunto, esta secuencia significa que podemos definir una opción footer usando Markdown bajo params en config.toml, e.g., [params] footer = &quot;&amp;copy; [Yihui Xie](https://yihui.name) 2017&quot; Hay una plantilla especial 404.html, que Hugo usa para crear la página 404 (cuando no se encuentra una página, se muestra esta página): {{ partial &quot;header.html&quot; . }} 404 NOT FOUND {{ partial &quot;footer.html&quot; . }} Con todas las plantillas anteriores, podremos generar un sitio web a partir de los archivos fuente de Markdown. Sin embargo, es poco probable que esté satisfecho con el sitio web porque los elementos HTML no tienen ningún estilo y la apariencia predeterminada puede no parecer atractiva para la mayoría de las personas. Puede haber notado que en header.html, hemos incluido dos archivos CSS, /css/style.css y /css/fonts.css. Puede encontrar muchos frameworks CSS de código abierto existentes que se pueden aplicar a un tema de Hugo. Por ejemplo, el framework CSS más popular puede ser Bootstrap: http://getbootstrap.com. Cuando estaba diseñando XMin, me preguntaba hasta dónde podría llegar sin usar ninguno de estos frameworks existentes, porque generalmente son muy grandes. Por ejemplo, bootstrap.css tiene casi 10000 líneas de código cuando no se minimiza. Resultó que pude obtener una apariencia satisfactoria con aproximadamente 50 líneas de CSS, que explicaré en detalle a continuación: style.css define todos los estilos excepto las fuentes tipográficas: body { max-width: 800px; margin: auto; padding: 1em; line-height: 1.5em; } El ancho máximo del cuerpo de la página se establece en 800 píxeles porque una página excesivamente ancha es difícil de leer (800 es un umbral arbitrario que elegí). El cuerpo se centra utilizando el truco de CSS margin: auto, lo que significa que los márgenes superior, derecho, inferior y izquierdo son automáticos. Cuando los márgenes izquierdo y derecho de un elemento de bloque son auto, estará centrado. /* header and footer areas */ .menu li { display: inline-block; } .article-meta, .menu a { text-decoration: none; background: #eee; padding: 5px; border-radius: 5px; } .menu, .article-meta, footer { text-align: center; } .title { font-size: 1.1em; } footer a { text-decoration: none; } hr { border-style: dashed; color: #ddd; } Recuerde que nuestro elemento de menú es una lista &lt;ul class=&quot;menu&quot;&gt; definida en header.html. Cambié el estilo de visualización predeterminado de &lt;li&gt; dentro del menú a inline-block, de modo que se distribuyan de izquierda a derecha como elementos en línea, en lugar de apilarse verticalmente como una lista de viñetas (el comportamiento predeterminado)) Para los enlaces (`’) en el menú y el área de metadatos de un artículo, se elimina la decoración de texto predeterminada (subrayados) y se aplica un color de fondo claro. El radio del borde se establece en 5 píxeles para que pueda ver un rectángulo sutil de esquina redondeada detrás de cada enlace. La regla horizontal (&lt;hr&gt;) se establece en una línea discontinua de color gris claro para que sea menos prominente en una página. Estas reglas se utilizan para separar el cuerpo del artículo de las áreas de encabezado y pie de página. /* code */ pre { border: 1px solid #ddd; box-shadow: 5px 5px 5px #eee; padding: 1em; overflow-x: auto; } code { background: #f9f9f9; } pre code { background: none; } Para bloques de código (&lt;pre&gt;), aplico bordes gris claro con efectos de sombra paralela. Cada elemento de código en línea tiene un fondo gris muy claro. Estas decoraciones son simplemente por mi propio interés y énfasis peculiares en el código. /* misc elements */ img, iframe, video { max-width: 100%; } main { hyphens: auto; } blockquote { background: #f9f9f9; border-left: 5px solid #ccc; padding: 3px 1em 3px; } table { margin: auto; border-top: 1px solid #666; border-bottom: 1px solid #666; } table thead th { border-bottom: 1px solid #ddd; } th, td { padding: 5px; } tr:nth-child(even) { background: #eee } Los elementos incrustados, como las imágenes y los videos que exceden el margen de la página, a menudo son desagradables, por lo que restrinjo su ancho máximo al 100%. La separación silábica está activada para palabras en &lt;main&gt;. Las citas en bloque tienen una barra lateral izquierda gris y un fondo gris claro. Las tablas están centradas de manera predeterminada, con solo tres reglas horizontales: los bordes superior e inferior de la tabla y el borde inferior de la tabla. Las filas de la tabla están rayadas para facilitar la lectura de la tabla, especialmente cuando la tabla es ancha. fonts.css es una hoja de estilo separada porque juega un papel crítico en la apariencia de un sitio web, y es muy probable que desee personalizar este archivo. En la mayoría de los casos, sus lectores dedicarán la mayor parte del tiempo a leer el texto en sus páginas, por lo que es importante hacer que el texto sea cómodo de leer. No soy un experto en diseño web, y acabo de elegir Palatino para el cuerpo y Lucida Console o Monaco (cualquiera que esté disponible en su sistema) para el código. Es común usar las fuentes web de Google hoy en día. Puede probar algunas fuentes web y ver si le gusta alguno de ellos. body { font-family: &quot;Palatino Linotype&quot;, &quot;Book Antiqua&quot;, Palatino, serif; } code { font-family: &quot;Lucida Console&quot;, Monaco, monospace; font-size: 85%; } Los dos archivos CSS se colocan bajo el directorio static/css/ del tema. En la plantilla HTML header.html, la ruta /css/style.css se refiere al archivo static/css/style.css. Por último, este tema proporcionó un sitio de ejemplo en exampleSite/. La estructura del directorio puede ser un poco confusa porque este es un tema en lugar de un sitio web. En la práctica, todo lo que se encuentra debajo de exampleSite/ debe estar debajo del directorio raíz de un sitio web, y el directorio hugo-xmin/ de nivel superior debe estar bajo el directorio themes/ de este sitio web, i.e., ├── config.toml ├── content/ ├── ... ├── themes/ │ └── hugo-xmin/ │ └── ... El sitio de ejemplo proporciona una muestra config.toml, una página de inicio _index.md, una página sobre about.md, dos publicaciones bajo note/ y dos bajo post/. También anula el foot_custom.html en el tema. 2.5.2 Implementando más funciones El XMin es en realidad un tema altamente funcional, pero entendemos que puede ser demasiado mínimo para usted. Hay algunas características comúnmente utilizadas (intencionalmente) que faltan en este tema, y le enseñaremos cómo agregarlas usted mismo si así lo desea. Todas estas características y el código fuente se pueden aplicar también a otros temas. Activar Google Analytics. Hugo ha proporcionado una plantilla parcial. Para XMin, puede agregar {{ template &quot;_internal/google_analytics.html&quot; . }} a layouts/partials/foot_custom.html bajo el directorio raiz de su sitio web (en lugar de themes/hugo-xmin/), y configurar googleAnalytics en el config.toml. Vea https://github.com/yihui/hugo-xmin/pull/3 para detalles, y la fuente HTML de esta página para el JavaScript renderizado desde la plantilla: https://deploy-preview-3--hugo-xmin.netlify.com. Activar comentarios Disqus. Similar a Google Analytics, puedes agregar la plantilla incorporada {{ template &quot;_internal/disqus.html&quot; . }} a foot_custom.html, y configurar el nombre corto Disqus en config.toml. Vea https://github.com/yihui/hugo-xmin/pull/4 para detalles, y una vista previa en https://deploy-preview-4--hugo-xmin.netlify.com. Configurar sintaxis resaltada mediante highlight.js. Agregue esto a head_custom.html &lt;link href=&quot;//YOUR-CDN-LINK/styles/github.min.css&quot; rel=&quot;stylesheet&quot;&gt; and this to foot_custom.html: &lt;script src=&quot;//YOUR-CDN-LINK/highlight.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//YOUR-CDN-LINK/languages/r.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; hljs.configure({languages: []}); hljs.initHighlightingOnLoad(); &lt;/script&gt; Recuerde reemplazar YOUR-CDN-LINK con el enlace al host de CDN preferido de highlight.js, por ejemplo,cdn.bootcss.com/highlight.js/9.12.0. Para obtener más información sobre highlight.js, consulte su página principal: https://highlightjs.org. Si necesita usar otros hosts CDN, cdnjs.com es una buena opción: https://cdnjs.com/libraries/highlight.js. También puede ver qué idiomas y temas CSS son compatibles allí. Puede ver https://github.com/yihui/hugo-xmin/pull/5 para una implementación real, y una página de muestra con resaltado de sintaxis en https://deploy-preview-5--hugo-xmin.netlify.com/post/2016/02/14/a-plain-markdown-post/. Soporte para expresiones matemáticas a través de MathJax. Agregue el código de abajo a foot_custom.html. &lt;script src=&quot;//yihui.name/js/math-code.js&quot;&gt;&lt;/script&gt; &lt;script async src=&quot;//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt; &lt;/script&gt; Esto requiere un conocimiento sustancial de JavaScript y la familiaridad con MathJax para comprender completamente el código anterior, y dejaremos la explicación del código en la sección B.3. Tenga en cuenta que bootcss.com es solo un posible servidor CDN de MathJax, y usted es libre de usar otros hosts. Mostrar la tabla de contenidos (TOC). Para mostrar una TOC para las publicaciones R Markdown, solo necesita agregar el formato de salida blogdown::html_page con la opción toc: true al YAML: output: blogdown::html_page: toc: true Para las publicaciones simples de Markdown, debe modificar la plantilla single.html. La TOC de una publicación se almacena en la variable de plantilla Hugo .TableOfContents. Es posible que desee una opción para controlar si mostrar la TOC, por ejemplo, puede agregar una opción toc: true a los metadatos YAML de una publicación de marcado para mostrar la TOC. El código a continuación se puede agregar antes del contenido de una publicación en single.html: {{ if .Params.toc }} {{ .TableOfContents }} {{ end }} Vea https://github.com/yihui/hugo-xmin/pull/7 para una implementación con ejemplos. Mostrar categorías y etiquetas en una publicación si se proporciona en su YAML. Agregue el código de abajo donde usted quiera ubicar las categorías y etiquetas en single.html, e.g., en &lt;div class=&quot;article-meta&quot;&gt;&lt;/div&gt;. &lt;p class=&quot;terms&quot;&gt; {{ range $i := (slice &quot;categories&quot; &quot;tags&quot;) }} {{ with ($.Param $i) }} {{ $i | title }}: {{ range $k := . }} &lt;a href=&#39;{{ relURL (print &quot;/&quot; $i &quot;/&quot; $k | urlize) }}&#39;&gt;{{$k}}&lt;/a&gt; {{ end }} {{ end }} {{ end }} &lt;/p&gt; Básicamente, el código recorre los campos de metadatos de YAML categories y tags, y para cada campo, su valor se obtiene de .Param, luego usamos un bucle interno para escribir los términos con enlaces de la forma &lt;a href=&quot;/tags/foo/&quot;&gt;foo&lt;/a&gt;. Puede ver https://github.com/yihui/hugo-xmin/pull/2 para la implementación completa y una previsualización en https://deploy-preview-2--hugo-xmin.netlify.com/post/2016/02/14/a-plain-markdown-post/. Agregar paginación. Cuando tiene una gran cantidad de publicaciones en un sitio web, es posible que no desee mostrar la lista completa en una sola página, pero muestre N publicaciones (por ejemplo, N = 10) por página. Es fácil agregar paginación a un sitio web usando las funciones y plantillas integradas de Hugo. En lugar de recorrer todas las publicaciones en una plantilla de lista (por ejemplo, range .Data.Pages), pagine la lista completa de publicaciones usando la función .Paginate (por ejemplo, range (.Paginate .Data.Pages)). A continuación se muestra un fragmento de plantilla que puede insertar en su archivo de plantilla list.html: &lt;ul&gt; {{ $paginator := .Paginate .Data.Pages }} {{ range $paginator.Pages }} &lt;li&gt; &lt;span class=&quot;date&quot;&gt;{{ .Date.Format &quot;2006/01/02&quot; }}&lt;/span&gt; &lt;a href=&quot;{{ .URL }}&quot;&gt;{{ .Title }}&lt;/a&gt; &lt;/li&gt; {{ end }} &lt;/ul&gt; {{ template &quot;_internal/pagination.html&quot; . }} See https://github.com/yihui/hugo-xmin/pull/16 for a full implementation. Agregar un botón de edición de GitHub o un link a una página. Si ninguna de las características anteriores le parece emocionante (lo que no me sorprendería), esta pequeña característica es realmente un gran ejemplo de mostrarle el poder de los archivos de texto sin formato y los sitios web estáticos, cuando se combina con GitHub (u otros servicios que admiten la edición en línea de archivos de texto sin formato). Creo que sería difícil, si no imposible, implementar esta característica en marcos de sitios web dinámicos como WordPress. Básicamente, cuando navega por cualquier archivo de texto en un repositorio en GitHub, puede editarlos directamente en la página presionando el botón Editar (mire la figura @ref(fig: github-edit) para ver un ejemplo) si tiene una cuenta de GitHub. Si tiene acceso de escritura al repositorio, puede confirmar los cambios directamente en línea, de lo contrario, GitHub bifurca automáticamente el repositorio para que pueda editar el archivo en su propio repositorio, y GitHub lo guiará para crear un pull request al repositorio original. Cuando el propietario original ve el pull request, puede ver los cambios que ha realizado y decidir si los acepta o no, o le pide que haga más cambios. Aunque la terminología “pull request” es muy confusa para los principiantes,25. Es probablemente la característica más importante inventada por GitHub, porque hace que sea mucho más fácil para las personas hacer contribuciones. Lo que realmente es útil es que todo lo que necesita es una URL de forma fija para editar un archivo en GitHub: https://github.com/USER/REPO/edit/BRANCH/PATH/TO/FILE. Por ejemplo, https://github.com/rbind/yihui/edit/master/content/knitr/faq.md, donde USER es rbind, REPO es yihui, BRANCH es master, y la ruta del archivo es content/knitr/faq.md. La clave para implementar esta característica es la variable .File.Path, que nos da la ruta del archivo fuente de una página bajo content/, por ejemplo, post/foo.md. Si su sitio web solo utiliza archivos de Markdown simples, la implementación será muy simple. Omití la URL completa de GitHub en ... a continuación, de la cual un ejemplo podría ser https://github.com/rbind/yihui/edit/master/content/. {{ with .File.Path }} &lt;a href=&quot;https://github.com/.../{{ . }}&quot;&gt;Edit this page&lt;/a&gt; {{ end }} Sin embargo, el caso es un poco más complicado para los usuarios de blogdown, cuando se trata de publicaciones de R Markdown. No se puede usar .File.Path porque apunta al archivo de salida .html de un archivo .Rmd, mientras que el archivo .Rmd es el archivo fuente real. El botón o enlace Edit no debe apuntar al archivo .html. A continuación se muestra la implementación completa que puede agregar a un archivo de plantilla dependiendo de dónde desee mostrar el enlace Edit (por ejemplo, footer.html): {{ if .File.Path }} {{ $Rmd := (print .File.BaseFileName &quot;.Rmd&quot;) }} {{ if (where (readDir (print &quot;content/&quot; .File.Dir)) &quot;Name&quot; $Rmd) }} {{ $.Scratch.Set &quot;FilePath&quot; (print .File.Dir $Rmd) }} {{ else }} {{ $.Scratch.Set &quot;FilePath&quot; .File.Path }} {{ end }} {{ with .Site.Params.GithubEdit}} &lt;a href=&#39;{{ . }}{{ $.Scratch.Get &quot;FilePath&quot; }}&#39;&gt;Edit this page&lt;/a&gt; {{ end }} {{ end }} La lógica básica es que, para un archivo, si existe el mismo nombre de archivo con la extensión .Rmd, señalaremos el enlace Edit al archivo Rmd. Primero, definimos una variable $ Rmd para que sea el nombre de archivo con la extensión .Rmd. Luego verificamos si existe. Desafortunadamente, no hay ninguna función en Hugo como file.exists() en R, así que tenemos que usar un truco: liste todos los archivos bajo el directorio y vea si el archivo Rmd está en la lista. $ .Scratch es la forma de almacenar dinámicamente y obtener variables en las plantillas de Hugo. La mayoría de las variables en Hugo son de solo lectura, y usted tiene que usar $.Scratch cuando quiera modificar una variable. Establecemos una variable FilePath en $.Scratch, cuyo valor es la ruta completa al archivo Rmd cuando existe el archivo Rmd, y la ruta al archivo fuente de Markdown de lo contrario. Finalmente, concatenamos una opción personalizada GithubEdit en config.toml con la ruta del archivo para completar el enlace Edit &lt;a&gt;. Aquí hay un ejemplo de la opción en config.toml: [params] GithubEdit = &quot;https://github.com/rbind/yihui/edit/master/content/&quot; Tenga en cuenta que si utiliza Hugo en Windows para compilar e implementar su sitio, es posible que tenga que cambiar los separadores de ruta de archivos de las barras diagonales inversas a barras diagonales, por ejemplo, puede necesitar {{$.Scratch.Set &quot;FilePath&quot; (replace ($.Scratch.Get&quot;FilePath&quot;) &quot;\\\\&quot; &quot;/&quot;)}} en la plantilla. Para evitar esta complicación, no recomendamos que implemente su sitio a través de Windows (consulte el capítulo ?? para conocer los métodos de implementación). Puede ver https://github.com/yihui/hugo-xmin/pull/6 para una implementación real con ejemplos de R Markdown, y ver el pie de página de esta página para el enlace Edit: https://deploy-preview-6--hugo-xmin.netlify.com. En realidad, puede ver un enlace en el pie de página de cada página, excepto las listas de páginas (porque no tienen archivos fuente). FIGURA 2.3: Editar un archivo de texto en línea en GitHub. Después de digerir el tema XMin y las implementaciones de funciones adicionales, debería ser mucho más fácil entender las plantillas de otras personas. Hay una gran cantidad de temas de Hugo, pero las principales diferencias entre ellos suelen ser estilos. Los componentes básicos de las plantillas son a menudo similares. La funcionalidad más común de las plantillas es hacer páginas HTML, pero también puede haber plantillas especiales, por ejemplo, para fuentes RSS y sitemaps, que son archivos XML.↩ En mi opinión, en realidad debería llamarse “solicitud de fusión”↩ "],
["layouts-personalizados.html", "2.6 Layouts personalizados", " 2.6 Layouts personalizados Es muy probable que desee personalizar un tema a menos que lo haya diseñado. La forma más directa es simplemente hacer cambios directamente en el tema,26 Pero el problema es que un tema de Hugo puede ser actualizado constantemente por su autor original para mejoras o correcciones de errores. De manera similar a la política “la rompes, la compras” (la regla de Pottery Barn), una vez que toca el código fuente de otra persona, será responsable de su mantenimiento futuro, y el autor original no debería ser responsable de los cambios que haya realizado de su lado. Eso significa que puede no ser fácil extraer actualizaciones futuras de este tema a su sitio web (debe leer cuidadosamente los cambios y asegurarse de que no entren en conflicto con sus cambios), pero si está completamente satisfecho con el estado actual del tema y no quiere actualizaciones futuras, está bien modificar los archivos de tema directamente. Un autor de tema que tenga en cuenta el hecho de que los usuarios pueden personalizar su tema generalmente proporcionará dos maneras: una es proporcionar opciones en config.toml, para que pueda cambiar estas opciones sin tocar los archivos de la plantilla; la otra es dejar unos pocos archivos de plantilla livianos en ‘layouts/’ en el tema, para que pueda anularlos sin tocar los archivos de la plantilla principal. Tome el tema XMin por ejemplo: Tengo dos archivos HTML vacíos head_custom.html y foot_custom.html en layouts/partials/ en el tema. El primero se agregará dentro de &lt;head&gt; &lt;/head&gt; de una página, por ejemplo, puede cargar librerías de JavaScript o incluir hojas de estilo CSS mediante &lt;link&gt;. Este último se agregará antes del pie de página de una página, por ejemplo, puede cargar librerías de JavaScript adicionales o incrustar comentarios de Disqus allí. La forma en que personaliza estos dos archivos no es para editarlos directamente en la carpeta de temas, sino para crear un directorio layouts/partials/ en el directorio raíz de su sitio web, por ejemplo, su estructura de directorios puede verse así: your-website/ ├── config.toml ├── ... ├── themes/ │ └── hugo-xmin/ │ ├── ... │ └── layouts/ │ ├── ... │ └── partials │ ├── foot_custom.html │ ├── footer.html │ ├── head_custom.html │ └── header.html └── layouts └── partials ├── foot_custom.html └── head_custom.html Todos los archivos en layouts/ en el directorio raíz anularán los archivos con las mismas rutas relativas en themes/hugo-xmin/layouts/, por ejemplo, el archivo layouts/partials/foot_custom.html, cuando se proporcione, anulará themes/hugo-xmin/layouts/partials/foot_custom.html. Eso significa que solo necesita crear y mantener como máximo dos archivos en layouts/ en lugar de mantener todos los archivos bajo themes/. Tenga en cuenta que este mecanismo de anulación se aplica a todos los archivos en layouts/, y no está limitado al directorio parials/. También se aplica a cualquier tema de Hugo que utilice realmente para su sitio web, y no se limita a hugo-xmin. Si es nuevo en el desarrollo web, tenga cuidado de cambiar el contenido dentro del tema. Pequeños cambios como colores y tamaños de fuente se pueden encontrar dentro de los archivos CSS del tema y pueden modificarse simplemente con el mínimo riesgo de romper la funcionalidad del tema.↩ "],
["archivos-estaticos.html", "2.7 Archivos estáticos", " 2.7 Archivos estáticos Todos los archivos bajo el directorio static/ se copian a public/ cuando Hugo procesa un sitio web. Este directorio se usa a menudo para almacenar archivos web estáticos como imágenes, CSS y archivos de JavaScript. Por ejemplo, una imagen static/foo/bar.png se puede incrustar en su publicación usando la sintaxis Markdown ![](/foo/bar.png).27 Por lo general, un tema tiene una carpeta static/, y puede anular parcialmente sus archivos utilizando el mismo mecanismo que reemplaza a los layouts/ archivos, es decir, static/file anulará themes/theme-name/static/file . En el tema XMin, tengo dos archivos CSS style.css y fonts.css. El primero es la hoja de estilo principal, y el último es un archivo bastante pequeño para definir tipos de letra solamente. Es posible que desee definir sus propios tipos de letra, y solo puede proporcionar un static/css/fonts.css para anular el del tema, por ejemplo, body { font-family: &quot;Comic Sans MS&quot;, cursive, sans-serif; } code { font-family: &quot;Courier New&quot;, Courier, monospace; } Para los usuarios de R Markdown, otra aplicación importante del directorio static/ es construir documentos Rmd con formatos de salida personalizados, es decir, documentos Rmd que no utilizan el formato blogdown::html_page() (ver sección ??). Por ejemplo, puede generar un PDF o presentaciones de documentos Rmd en este directorio, para que Hugo no los postprocesa, sino que simplemente los copie en public/ para su publicación. Para compilar estos archivos Rmd, debe proporcionar un script de compilación personalizado R/build.R (consulte la sección D.9). Puede escribir una sola línea de código en este script: blogdown::build_dir(&quot;static&quot;) La función build_dir() busca todos los archivos Rmd bajo un directorio y llama a rmarkdown::render() para compilarlos en los formatos de salida especificados en los metadatos YAML de los archivos Rmd. Si sus archivos Rmd no se deben presentar con una simple llamada rmarkdown::render(), puede proporcionar su propio código para presentarlos en R/build.R. Hay un mecanismo de caché integrado en la función dir_desarrollo(): un archivo Rmd no se compilará si es anterior a su archivo(s) de salida. Si no desea este comportamiento, puede obligar a todos los archivos Rmd a volver a compilarse cada vez: build_dir(force = TRUE). He proporcionado un ejemplo mínimo en el repositorio de GitHub yihui/blogdown-static, donde puede encontrar dos ejemplos de Rmd en el directorio static/. Una es una presentación HTML5 basada en el paquete xaringan, y la otra es un documento PDF basado en bookdown. Debe tener precaución con los archivos arbitrarios en static/, debido al mecanismo predominante de Hugo. Es decir, todo en static/ se copiará en public/. Debe asegurarse de que los archivos que procesa en static/ no entrarán en conflicto con los archivos generados automáticamente por Hugo a partir de content/. Por ejemplo, si tiene un archivo fuente content/about.md y un archivo Rmd static/about/index.Rmd al mismo tiempo, el resultado HTML de este último sobrescribirá el anterior (tanto Hugo como usted generarán un archivo de salida con el mismo nombre public/about/index.html). El enlace de la imagen depende de su configuración baseurl en config.toml. Si no contiene un subtrayecto, /foo/bar.png será el enlace de la imagen; de lo contrario, tendrá que ajustarlo, por ejemplo, para baseurl = &quot;http://example.com/subpath/&quot;, el enlace a la imagen debe ser /subpath/foo/bar.png.↩ "],
["implementacion.html", "Capítulo 3 Implementación", " Capítulo 3 Implementación Dado que el sitio web es básicamente una carpeta que contiene archivos estáticos, es mucho más fácil de implementar que los sitios web que requieren lenguajes dinámicos en el servidor, como PHP o bases de datos. Todo lo que necesita es subir los archivos a un servidor, y generalmente su sitio web estará en funcionamiento en breve. La pregunta clave es qué servidor web quiere usar. Si no tiene su propio servidor, puede probar los que figuran en este capítulo. La mayoría de ellos son gratuitos (excepto Amazon S3), o al menos ofrecen planes gratuitos. Descargo de responsabilidad: los autores de este libro no están afiliados a ninguno de estos servicios o compañías, y no hay garantía de que estos servicios se presten para siempre.28. Teniendo en cuenta el costo y la amabilidad de los principiantes, actualmente recomendamos Netlify (https://www.netlify.com). Proporciona un plan gratuito que en realidad tiene muchas funciones útiles. Si no tiene experiencia en publicar sitios web antes, solo inicie sesión con su cuenta GitHub u otras cuentas, arrastre la carpeta public/ creada por blogdown para su sitio web a la página de Netlify, y su sitio web estará en línea en unos segundos con un nombre de subdominio aleatorio del formulario random-word-12345.netlify.com proporcionado por Netlify (puede personalizar el nombre). Puede automatizar fácilmente este proceso (consulte la sección 3.1 para obtener más información). Ya no necesita luchar con ssh o rsync-zrvce, si sabe lo que significan estos comandos. La segunda solución más fácil puede ser Updog (https://updog.co), que cuenta con la integración de Dropbox. Publicar un sitio web puede ser tan fácil como copiar los archivos en la carpeta public/ de su sitio web blogdown en una carpeta de Dropbox. El plan gratuito de Updog solo ofrece funciones limitadas, y su plan de pago le dará acceso a funciones mucho más ricas. Si no le importa utilizar herramientas de línea de comandos o está familiarizado con GIT/GitHub, puede considerar servicios como GitHub Pages, Travis CI o Amazon S3 para construir o alojar sus sitios web. No importa qué servicio use, tenga en cuenta que ninguno de ellos realmente puede encerrarlo y siempre puede cambiar el servicio. Como mencionamos anteriormente, una gran ventaja de blogdown es que su sitio web será una carpeta de archivos estáticos que puede mover a cualquier servidor web. Puede encontrar fácilmente otros servicios similares si usa su motor de búsqueda↩ "],
["netlify.html", "3.1 Netlify", " 3.1 Netlify Como acabamos de mencionar, Netlify le permite publicar rápidamente un sitio web cargando la carpeta public/ a través de su interfaz web, y se le asignará un subdominio aleatorio *.netlify.com.29 Este enfoque es bueno para los sitios web que no se actualizan con frecuencia (o no se actualizan). Sin embargo, es poco probable que no necesite actualizar su sitio web, por lo que presentamos un mejor enfoque en esta sección,30. Le llevará unos minutos más completar las configuraciones. Una vez que está configurado correctamente, todo lo que necesita hacer en el futuro es actualizar el repositorio fuente, y Netlify llamará a Hugo para que haga su sitio web automáticamente. Básicamente, debe alojar todos los archivos fuente de su sitio web en un repositorio GIT.31 No necesita poner el directorio public/ bajo control de versión32 porque se generará automáticamente. Actualmente, Netlify admite repositorios GIT alojados en GitHub, GitLab y BitBucket. Con cualquiera de estas cuentas, puede iniciar sesión en Netlify desde su página de inicio y seguir la guía para crear un nuevo sitio desde su repositorio de GIT. Netlify es compatible con varios generadores de sitios web estáticos, incluidos Jekyll y Hugo. Para un nuevo sitio, debe especificar un comando para construir su sitio web, así como también la ruta del directorio de publicación. Netlify también admite múltiples versiones de Hugo, por lo que el comando de compilación puede ser el hugo predeterminado. La versión predeterminada es 0.17, que es demasiado antigua. Le recomendamos que utilice al menos la versión 0.20. Para especificar una versión de Hugo mayor o igual a 0.20, debe crear una variable de entorno HUGO_VERSION en Netlify. Consulte la documentación de Netlify para obtener más información. El directorio de publicación debe ser public a menos que lo haya cambiado en su config.toml. La figura @ref(fig: configuración-netlify) muestra la configuración del sitio web https://t.yihui.name. No tiene que seguir la configuración exacta para su propio sitio web; en particular, es posible que necesite cambiar el valor de la variable de entorno HUGO_VERSION a una versión reciente de Hugo.33 FIGURA 3.1: Configuraciones de ejemplo de un sitio web presentado en Netlify. Puede tardar uno o dos minutos en implementar su sitio web en Netlify por primera vez, pero puede ser mucho más rápido más adelante (unos segundos) cuando actualice el origen de su sitio web, porque Netlify implementa cambios incrementales en el directorio public/, es decir, solo se despliegan los archivos más nuevos en comparación con la última vez. Después de que su repositorio de GIT esté conectado con Netlify, el último problema que puede querer resolver es el nombre de dominio, a menos que esté satisfecho con el subdominio gratuito de Netlify. Si desea utilizar un dominio diferente, debe configurar algunos registros DNS del dominio para dirigirlo al servidor de Netlify. Consulte el apéndice @ref(nombre de dominio) para obtener información general sobre los nombres de dominio. Si no está familiarizado con los nombres de dominio o no quiere aprender más sobre ellos, debe tener en cuenta un subdominio gratuito * .rbind.io ofrecido por RStudio, Inc. Visite el sitio web de soporte de Rbind https://support.rbind.io para aprender cómo solicitar un subdominio. De hecho, la organización Rbind también ofrece ayuda gratuita sobre cómo configurar un sitio web basado en blogdown, gracias a una gran cantidad de voluntarios de la comunidad de R y de estadística. Netlify es la única solución en este capítulo que no requiere preinstalar su sitio web. Solo necesita actualizar los archivos fuente, enviarlos a GitHub y Netlify creará el sitio web para usted.34. El resto de las soluciones de este capítulo requerirán que cree su sitio web localmente. y cargue la carpeta public/ explícita o implícitamente. Dicho esto, ciertamente puede preconstruir su sitio web utilizando cualquier herramienta, enviarlo a GitHub, y aún así Netlify lo implementará para usted. Lo que debe hacer es dejar el comando de compilación en blanco y decirle a Netlify su directorio de publicación (por ejemplo, public/ por defecto de Hugo, pero si su sitio web preconstruido está bajo el directorio raíz, especifique . como el directorio de publicación). Entonces Netlify simplemente carga todos los archivos de este directorio a sus servidores sin reconstruir su sitio web. Usted no tiene que mantener el dominio *.netlify.com. Consulte el apéndice @ref(nombre de dominio) para obtener más información.↩ Tenga en cuenta que el propósito de esta sección es describir los pasos básicos de la publicación de un sitio web con Netlify, y los detalles técnicos pueden cambiar de vez en cuando, por lo que la documentación oficial de Netlify debería ser la fuente más confiable si tiene alguna pregunta o si alguna de las cosas que presentamos aquí no funciona↩ Si el contenido de su sitio blogdown no está en el directorio raíz de su repositorio GIT, Netlify no se compilará.↩ Puede agregar public a .gitignore para ignorarlo en GIT.↩ Para el momento en que se publique este libro, la versión 0.24.1 puede ser demasiado antigua.↩ Esto se denomina “implementación continua”↩ "],
["updog.html", "3.2 Updog", " 3.2 Updog Updog (https://updog.co) proporciona un servicio simple: convierte una carpeta de Dropbox (o Google Drive) especificada en un sitio web. La idea es que le conceda a Updog el permiso para leer la carpeta, y actuará como intermediario para mostrar sus archivos en esta carpeta a sus visitantes. Se debe acceder a esta carpeta a través de un nombre de dominio, y Updog ofrece un subdominio gratuito *.updog.co. Por ejemplo, si ha asignado el dominio example.updog.co a su carpeta de Dropbox, y un visitante desea ver la página https://example.updog.co/foo/index.html, Updog leerá el archivo foo/index.html en su carpeta de Dropbox y lo mostrará al visitante. Por el momento, el plan gratuito de Updog solo permite un sitio web por cuenta e insertará un pie de página “Hosted on Updog” en sus páginas web. Puede que no le gusten estas limitaciones. La principal ventaja de usar Updog es que la publicación de un sitio web se vuelve implícita, ya que Dropbox sincronizará archivos continuamente. Todo lo que necesita hacer es asegurarse de que su sitio web se genere en la carpeta correcta de Dropbox. Esto se puede lograr fácilmente estableciendo la opción publishDir en config.toml. Por ejemplo, supongamos que la carpeta que asigna a Updog es ~/Dropbox/Apps/updog/my-website/, y su carpeta fuente está en ~/Dropbox/Apps/updog/my-source/, entonces puede establecer publishDir: &quot;../my-website&quot; en ~/Dropbox/Apps/updog/my-source/config.toml. También puede usar su nombre de dominio personalizado si no desea el subdominio Updog predeterminado, y solo necesita apuntar el registro CNAME de su nombre de dominio al subdominio Updog.35 Vea el apéndice @ref(nombre de dominio) para obtener más información.↩ "],
["github-pages.html", "3.3 GitHub Pages", " 3.3 GitHub Pages GitHub Pages (https://pages.github.com) es una forma muy popular de alojar sitios web estáticos (especialmente los creados con Jekyll), pero sus ventajas no son obvias ni atractivas en comparación con Netlify. Le recomendamos que considere Netlify + Hugo debido a estas razones: Actualmente, GitHub Pages no es compatible con HTTPS para nombres de dominio personalizados. HTTPS solo funciona para los subdominios *.github.io. Esta limitación no existe en Netlify. Puede leer el artículo “¿Por qué HTTPS para todo?” para comprender por qué es importante y se le anima a activar HTTPS para su sitio web siempre que sea posible. Redirigir URLs es incómodo con GitHub Pages pero mucho más sencillo con Netlify.36 Esto es importante especialmente cuando tiene un sitio web antiguo que desea migrar a Hugo; algunos enlaces pueden estar rotos, en cuyo caso puede redireccionarlos fácilmente con Netlify. Una de las mejores características de Netlify que no está disponible en GitHub Pages es que Netlify puede generar un sitio web único para la vista previa cuando se envía un pull request de GitHub a su repositorio de GitHub. Esto es extremadamente útil cuando otra persona (o incluso usted mismo) propone cambios en su sitio web, ya que tiene la oportunidad de ver cómo se vería el sitio web antes de fusionar el pull request. Básicamente, Netlify puede hacer todo lo que GitHub Pages puede, pero todavía hay una pequeña característica que falta, que está estrechamente vinculada a GitHub, que es GitHub Project Pages.. Esta función le permite tener sitios web de proyectos en repositorios separados, por ejemplo, puede tener dos sitios web independientes https://username.github.io/proj-a/ y https://username.github.io/proj-b/, que corresponde a los repositorios de GitHub username/proj-a y username/proj-b, respectivamente. Sin embargo, dado que puede conectar cualquier repositorio de GitHub con Netlify, y cada repositorio puede asociarse con un nombre de dominio o subdominio, puede reemplazar las páginas de proyecto de GitHub con diferentes subdominios como proj-a.netlify.com y proj-b.netlify.com. La limitación real es que no puede usar subcampos en la URL pero puede usar cualquier (sub)nombre de dominio. Aunque GitHub no es compatible oficialmente con Hugo (solo es compatible con Jekyll), puede publicar cualquier archivo HTML estático en GitHub Pages, incluso si no están compiladas con Jekyll. El primer requisito para usar GitHub Pages es que debe crear un repositorio de GitHub llamado username.github.io debajo de su cuenta (reemplace username con su nombre de usuario GitHub real), y lo que queda es llevar los archivos de su sitio web a este repositorio. La documentación completa de GitHub Pages está en https://pages.github.com, y por favor ignore todo lo relacionado con Jekyll a menos que realmente use Jekyll en lugar de Hugo. Para asegurarse de que GitHub no reconstruya su sitio web utilizando Jekyll y simplemente publique los archivos que envía al repositorio, debe crear un archivo (oculto) llamado .nojekyll en el repositorio.37 GitHub ofrece un subdominio gratuito username.github.io, y puede usar su propio nombre de dominio configurando sus registros A o CNAME para apuntarlo a GitHub Pages (consulte la documentación de GitHub Pages para obtener instrucciones). Su directorio public/ debe ser el repositorio de GIT. Tienes dos opciones posibles para configurar este repositorio localmente. La primera opción es seguir la estructura predeterminada de un sitio web de Hugo como el siguiente diagrama e inicializar el repositorio de GIT bajo el directorio public/: source/ │ ├── config.toml ├── content/ ├── themes/ ├── ... └── public/ | ├── .git/ ├── .nojekyll ├── index.html ├── about/ └── ... Si sabe cómo usar la línea de comandos, cambie el directorio de trabajo a public/, e inicialice el repositorio de GIT allí: cd public git init git remote add origin https://github.com/username/username.github.io La otra opción es clonar el repositorio de GitHub que creó en el mismo directorio que el origen de su sitio web: git clone https://github.com/username/username.github.io Y la estructura debería lucir más o menos así: source/ │ ├── config.toml ├── content/ ├── themes/ └── ... username.github.io/ │ ├── .git/ ├── .nojekyll ├── index.html ├── about/ └── ... El directorio de origen y el directorio username.github.io están bajo el mismo directorio principal. En este caso, debe establecer la opción publishDir: &quot;../username.github.io&quot; en source/config.toml. GitHub Pages utiliza un plugin Jekyll para escribir una metaetiqueta HTTP-REFRESH para redirigir páginas, y Netlify puede hacer redirecciones 301 o 302 basadas en patrones, que puede notificar a los motores de búsqueda que ciertas páginas se han movido (de forma permanente o temporal).↩ Puede usar la función en R file.create('.nojekyll') para crear este archivo si no sabe cómo hacerlo.↩ "],
["travis-github.html", "3.4 Travis + GitHub", " 3.4 Travis + GitHub Si decide no seguir nuestra recomendación de usar Netlify para implementar su sitio web, debemos advertirle que el enfoque de esta sección requerirá un conocimiento sustancial sobre GIT, GitHub, Travis CI (https://travis-ci.org), y la línea de comandos de Linux, que dejaremos que aprenda por su cuenta. La principal ventaja de publicar a través de Travis CI es que puede compilar todas sus publicaciones de Rmd en Travis CI (en la nube) en lugar de su computadora local. En caso de que no esté familiarizado con Travis, este es un servicio de verificación continua de su software en una máquina virtual cada vez que haga push a cambios en GitHub. Es principalmente para probar software, pero dado que puede ejecutar muchos comandos en su máquina virtual, puede usar la máquina virtual para hacer otras cosas, por ejemplo, instalar R y el paquete blogdown para crear sitios web. Antes de mostrarle cómo, me gustaría mencionar dos cuestiones que debe tener en cuenta: Personalmente, prefiero echar un vistazo a la salida en GIT para ver los cambios cuando tengo cualquier salida que se calcula dinámicamente desde R, para que sepa con certeza qué voy a publicar exactamente. Con Travis, es algo impredecible porque es completamente automático y no tiene la oportunidad de ver el nuevo contenido o los resultados que se publicarán. Hay muchos factores que pueden afectar la construcción del sitio: la versión de R, la disponibilidad de ciertos paquetes en R, las dependencias del sistema y la conexión de red, etc. El tiempo requerido para compilar todos los archivos Rmd puede ser muy largo y causar tiempos de espera en Travis, dependiendo de cuánto tiempo consuma su código en R. Hay un mecanismo de almacenamiento en caché en blogdown para acelerar la construcción de su sitio (consulte la sección D.9), y si usa Travis para construir su sitio web, no se beneficiará de este mecanismo de almacenamiento en caché a menos que aproveche el almacenamiento en caché de Travis. Tiene que almacenar en caché los directorios content/, static/, y blogdown/, pero el caché de Travis es un poco frágil, en mi experiencia. Algunas veces la memoria caché puede ser purgada por razones desconocidas. Además, no puede almacenar en caché directamente content/ y static/, porque Travis clona su repositorio antes de restaurar el caché, lo que significa que los archivos viejos del content/ y static/ almacenados en caché pueden sobrescribir los nuevos archivos que usted envió a GitHub. El segundo problema se puede resolver, pero no quiero explicar cómo en este libro, ya que la solución es demasiado complicada. Si realmente desea usar Travis para construir su sitio web y encontrarse con este problema, puede presentar un issue en el repositorio de GitHub https://github.com/yihui/travis-blogdown. De hecho, este repositorio es un ejemplo mínimo que creé para mostrar cómo crear un sitio web en Travis y publicarlo en GitHub Pages. La documentación de Travis muestra cómo implementar un sitio en GitHub Pages: https://docs.travis-ci.com/user/deployment/pages/, pero no muestra cómo crear un sitio. Aquí está el archivo de configuración de Travis, .travis.yml, para el repositorio travis-blogdown: language: r dist: trusty sudo: false branches: only: - master cache: packages: yes directories: - $HOME/bin before_script: - &quot;Rscript -e &#39;blogdown::install_hugo()&#39;&quot; script: - &quot;Rscript -e &#39;blogdown::build_site()&#39;&quot; deploy: provider: pages skip_cleanup: true github_token: $GITHUB_TOKEN on: branch: master local_dir: public fqdn: travis-blogdown.yihui.name La clave es que instalemos Hugo a través de blogdown::install_hugo() y construyamos el sitio a través de blogdown::build_site(). Para engañar a Travis para que cree este repositorio como un paquete en R, debe tener un archivo DESCRIPTION en el repositorio, de lo contrario, su sitio web no se compilará. Package: placeholder Type: Website Title: Does not matter. Version: 0.0.1 Imports: blogdown Remotes: rstudio/blogdown Hay algunas cosas más que explicar y enfatizar en .travis.yml: La opción branches especifica que solo los cambios en la rama master activarán la construcción en Travis. La opción cache especifica todos los paquetes en R que se almacenarán en caché, por lo que la próxima vez será más rápido crear el sitio (no es necesario volver a instalar los paquetes en R desde el origen). El directorio bin/ en el directorio de inicio también se almacena en caché porque Hugo está instalado allí, y la próxima vez que Hugo no necesite ser reinstalado. Para la opción deploy, hay una variable de entorno llamada GITHUB_TOKEN, y he especificado su valor para ser un token de acceso personal de GitHub a través de la configuración de Travis de este repositorio, para que Travis pueda escribir en mi repositorio después de que el sitio web está construido. La opción on especifica que la implementación solo ocurrirá cuando se construya la rama master. La opción local_dir es el directorio de publicación, que debe ser ‘público’ por defecto en Hugo. Por defecto, el sitio web se envía a la rama gh-pages de este repositorio. La opción fqdn especifica el dominio personalizado del sitio web. He establecido un registro CNAME (ver apéndice @ref(nombre de dominio)) para apuntar travis-blogdown.yihui.name a yihui.github.io, para que GitHub pueda servir a este sitio web a través de este dominio (de hecho, Travis escribirá un archivo CNAME que contiene el dominio en la rama gh-pages). Si utiliza el repositorio username.github.io en GitHub, el sitio web debe ser enviado a su rama master en lugar de gh-pages (esta es la única excepción). Recomiendo que separe el repositorio fuente y el repositorio de salida. Por ejemplo, puede tener un repositorio website-source con la misma configuración que el .travis.yml anterior, excepto dos nuevas opciones bajo deploy: deploy: ... repo: username/username.github.io target_branch: master Esto significa que el sitio web será enviado a la rama master del repositorio username/username.github.io (recuerde reemplazar username con su nombre de usuario real). También puede implementar su sitio web en Amazon S3, y la configuración desde R es muy similar a lo que hemos introducido para GitHub Pages. La única diferencia está en el último paso, donde cambia el destino de GitHub Pages a Amazon S3. Para obtener más información, consulte la documentación de Travis: https://docs.travis-ci.com/user/deployment/s3/. "],
["gitlab-pages.html", "3.5 GitLab Pages", " 3.5 GitLab Pages GitLab (http://gitlab.com) es una forma muy popular de alojar el código fuente de su proyecto. GitLab tiene un servicio de Integración y Despliegue Integrado (CI/CD) que se puede usar para alojar sitios web estáticos, llamados Páginas de GitLab. La principal ventaja de utilizar GitLab Pages es que podrá compilar todas sus publicaciones Rmd a través de su servicio CI/CD en lugar de su computadora local y cualquier contenido generado, como archivos HTML, se copiará automáticamente en el servidor web. Tenga en cuenta que este enfoque tiene problemas similares a los del enfoque Travis + GitHub en la sección 3.4. El servicio CI/CD de GitLab usa las instrucciones almacenadas en el archivo YAML .gitlab-ci.yml en el repositorio. Aquí hay un archivo de configuración de muestra .gitlab-ci.yml del repositorio de ejemplo https://gitlab.com/rgaiacs/blogdown-gitlab: image: debian:buster-slim before_script: - apt-get update &amp;&amp; apt-get -y install pandoc r-base - R -e &quot;install.packages(&#39;blogdown&#39;,repos=&#39;http://cran.rstudio.com&#39;)&quot; - R -e &quot;blogdown::install_hugo()&quot; pages: script: - R -e &quot;blogdown::build_site()&quot; artifacts: paths: - public only: - master La opción image especifica qué imagen de Docker se usará como punto de inicio. Estamos utilizando una imagen de Debian, pero se puede usar cualquier imagen de Docker Hub. Otras configuraciones y opciones son similares a .travis.yml en la sección 3.4. El ejemplo anterior genera el sitio web en https://rgaiacs.gitlab.io/blogdown-gitlab. "],
["migration.html", "Capítulo 4 Migration", " Capítulo 4 Migration Por lo general, es más fácil iniciar un nuevo sitio web que migrar un antiguo a un nuevo framework, pero puede que tenga que hacerlo de todos modos debido al contenido útil en el viejo sitio web que no debe descartarse simplemente. Una solución perezosa es abandonar el sitio web antiguo tal como está, iniciar un nuevo sitio web con un nuevo dominio y proporcionar un enlace al sitio web anterior. Esto puede ser molesto para sus lectores, y es posible que no puedan descubrir fácilmente las gemas que usted creó en su sitio web antiguo, por lo que le recomendamos que migre sus publicaciones y páginas anteriores al nuevo sitio web si es posible. Este proceso puede ser fácil o difícil, dependiendo de lo complicado que sea el sitio web anterior. La mala noticia es que no es probable que haya una solución universal o mágica, pero he proporcionado algunas funciones de ayuda en blogdown y una aplicación Shiny para ayudarlo, lo que puede hacer que sea un poco más fácil para usted migrar de los sitios de Jekyll y WordPress. Para darle una idea sobre la posible cantidad de trabajo requerido, le puedo decir que me tomó una semana entera (de la mañana a la medianoche todos los días) migrar varios de mis sitios web personales basados en Jekyll a Hugo y blogdown. La complicación en mi caso no era solo Jekyll, sino también el hecho de que construí varios sitios web de Jekyll (porque no tenía opción en Jekyll) y quería unirlos en el mismo repositorio. Ahora mis dos blogs (chino e inglés), la documentación del paquete knitr (Xie 2018b) y la documentación del paquete animation (???) se mantienen en el mismo repositorio: https://github.com/rbind/yihui. Tengo alrededor de 1000 páginas en este sitio web, la mayoría de las cuales son publicaciones de blog. Solía llevarme más de 30 segundos obtener una vista previa de mi blog en Jekyll, y ahora toma menos de 2 segundos construir el sitio en Hugo. Otro ejemplo complicado es el sitio web de Rob J Hyndman (https://robjhyndman.com). Comenzó su sitio web en 1993 (12 años antes que yo), y había acumulado una gran cantidad de contenido a lo largo de los años. Puede leer la publicación https://support.rbind.io/2017/05/15/converting-robjhyndman-to-blogdown/ para las historias sobre cómo migró su sitio web de WordPress a blogdown. La clave es que probablemente necesite un vuelo internacional largo cuando desee migrar un sitio web complicado. Un ejemplo más simple es el blog Simply Statistics (https://simplystatistics.org). Originalmente fue construido en Jekyll38 Y la fuente se alojó en el repositorio de GitHub https://github.com/simplystats/simplystats.github.io. Me ofrecí como voluntario para ayudarlos a pasar a blogdown, y me tomó aproximadamente cuatro horas. Mi tiempo se gastó principalmente en limpiar los metadatos YAML de publicaciones y retocar el tema Hugo. Tenían alrededor de 1000 publicaciones, lo que parece mucho, pero el número en realidad no importa, porque escribí un guión en R para procesar todas las publicaciones automáticamente. El nuevo repositorio está en https://github.com/rbind/simplystats. Si realmente no tiene demasiadas páginas (por ejemplo, menos de 20), le recomiendo que las corte y las pegue en los archivos Markdown, porque en realidad puede llevar más tiempo escribir un script para procesar estas páginas. Es probable que algunos enlaces se rompan después de la migración porque Hugo genera diferentes enlaces para sus páginas y publicaciones. En ese caso, puede corregir los enlaces permanentes (por ejemplo, ajustando la barra de una publicación) o usar 301 redireccionamientos (por ejemplo, en Netlify). References "],
["desde-jekyll.html", "4.1 Desde Jekyll", " 4.1 Desde Jekyll Al convertir un sitio web de Jekyll en Hugo, la parte más desafiante es el tema. Si desea mantener exactamente el mismo tema, deberá volver a escribir las plantillas de Jekyll utilizando la sintaxis de Hugo (consulte la sección ??). Sin embargo, si puede encontrar un tema existente en Hugo (https://themes.gohugo.io), las cosas serán mucho más fáciles, y usted solo necesita mover el contenido de su sitio web a Hugo, lo cual es relativamente fácil. Básicamente, copie las páginas y publicaciones de Markdown en el directorio content/ en Hugo y modifique estos archivos de texto. Usualmente, las publicaciones en Jekyll están bajo el directorio _posts/, y puedes moverlas a content/post/ (puede usar otros directorios). Luego, debe definir una regla personalizada para las URL permanentes en config.toml (consulte la sección 2.2.2): [permalinks] post = &quot;/:year/:month/:day/:slug/&quot; Esto depende del formato de las URL que utilizó en Jekyll (consulte la opción permalink en su _config.yml). Si hay archivos estáticos como imágenes, se pueden mover al directorio static/ en Hugo. Luego necesita usar su herramienta favorita con algunas técnicas de manipulación de cadenas de caracteres para procesar todos los archivos Markdown. Si usa R, puede listar todos los archivos Markdown y procesarlos uno por uno en un bucle. A continuación se muestra un boceto del código: files = list.files( &#39;content/&#39;, &#39;[.](md|markdown)$&#39;, full.names = TRUE, recursive = TRUE ) for (f in files) { blogdown:::process_file(f, function(x) { # process x here and return the modified x x }) } La función process_file() es una función auxiliar interna en blogdown. Se necesita un nombre de archivo y una función de procesador para manipular el contenido del archivo y escribe el texto modificado de nuevo en el archivo. Para darle una idea de cómo puede ser una función de procesador, proporcioné algunas funciones simples de ayuda en blogdown, y a continuación hay dos de ellas: blogdown:::remove_extra_empty_lines function (f) process_file(f, function(x) { x = paste(gsub(&quot;\\\\s+$&quot;, &quot;&quot;, x), collapse = &quot;\\n&quot;) trim_ws(gsub(&quot;\\n{3,}&quot;, &quot;\\n\\n&quot;, x)) }) &lt;environment: namespace:blogdown&gt; blogdown:::process_bare_urls function (f) process_file(f, function(x) { gsub(&quot;\\\\[([^]]+)]\\\\(\\\\1/?\\\\)&quot;, &quot;&lt;\\\\1&gt;&quot;, x) }) &lt;environment: namespace:blogdown&gt; La primera función sustituye dos o más líneas vacías con una sola línea vacía. La segunda función reemplaza los enlaces de la forma [url](url) con &lt;url&gt;. Sin embargo, no hay nada de malo con las líneas vacías excesivas o la sintaxis [url](url). Estas funciones auxiliares pueden hacer que su texto de Markdown sea un poco más limpio. Puede encontrar todas las funciones auxiliares en https://github.com/rstudio/blogdown/blob/master/R/clean.R. Tenga en cuenta que no se exportan de blogdown, por lo que necesita tres puntos y coma para acceder a ellos. Es posible que los metadatos YAML de sus publicaciones no estén completamente limpios, especialmente cuando su sitio web Jekyll se convirtió de un sitio web anterior de WordPress. La función auxiliar interna blogdown:::modify_yaml() puede ayudarlo a limpiar los metadatos. Por ejemplo, a continuación se muestran los metadatos YAML de una publicación de blog de Simply Statistics cuando se creó en Jekyll: --- id: 4155 title: Announcing the JHU Data Science Hackathon 2015 date: 2015-07-28T13:31:04+00:00 author: Roger Peng layout: post guid: http://simplystatistics.org/?p=4155 permalink: /2015/07/28/announcing-the-jhu-data-science-hackathon-2015 pe_theme_meta: - &#39;O:8:&quot;stdClass&quot;:2:{s:7:&quot;gallery&quot;;O:8:&quot;stdClass&quot;:...}&#39; al2fb_facebook_link_id: - 136171103105421_837886222933902 al2fb_facebook_link_time: - 2015-07-28T17:31:11+00:00 al2fb_facebook_link_picture: - post=http://simplystatistics.org/?al2fb_image=1 dsq_thread_id: - 3980278933 categories: - Uncategorized --- Puede descartar los campos YAML que no son útiles en Hugo. Por ejemplo, solo puede mantener los campos title, author, date, categories y tags, y descartar otros campos. En realidad, es posible que también desee agregar un campo slug que tome el nombre de archivo base de la publicación (sin la fecha inicial). Por ejemplo, cuando el nombre del archivo postal es 2015-07-28-announceing-the-jhu-data-science-hackathon-2015.md, es posible que desee agregar slug: announcing-the-jhu-data-science-hackathon-2015 para asegurarse de que la URL de la publicación en el nuevo sitio siga siendo la misma. Aquí está el código para procesar los metadatos YAML de todas las publicaciones: for (f in files) { blogdown:::modify_yaml(f, slug = function(old, yaml) { # YYYY-mm-dd-name.md -&gt; name gsub(&#39;^\\\\d{4}-\\\\d{2}-\\\\d{2}-|[.](md|markdown)&#39;, &#39;&#39;, f) }, categories = function(old, yaml) { # remove the Uncategorized category setdiff(old, &#39;Uncategorized&#39;) }, .keep_fields = c( &#39;title&#39;, &#39;author&#39;, &#39;date&#39;, &#39;categories&#39;, &#39;tags&#39;, &#39;slug&#39; ), .keep_empty = FALSE) } Puede pasar una ruta de archivo a modify_yaml(), definir nuevos valores YAML (o funciones para devolver nuevos valores basados en los valores anteriores) y decidir qué campos conservar (.keep_fields). Puede descartar campos vacíos a través de .keep_empty = FALSE. Los metadatos YAML procesados están a continuación, lo que parece mucho más limpio: --- title: Announcing the JHU Data Science Hackathon 2015 author: Roger Peng date: &#39;2015-07-28T13:31:04+00:00&#39; slug: announcing-the-jhu-data-science-hackathon-2015 --- "],
["desde-wordpress.html", "4.2 Desde WordPress", " 4.2 Desde WordPress Según nuestra experiencia, la mejor manera de importar publicaciones de blog de WordPress a Hugo es importarlas a Jekyll, y escribir un script en R para limpiar los metadatos YAML de todas las páginas si es necesario, en lugar de usar las herramientas de migración listadas en la guía oficial, incluyendo el plugin de WordPress wordpress-to-hugo-exporter. Hasta donde sabemos, la mejor herramienta para convertir un sitio web de WordPress a Jekyll es la herramienta de Python Exitwp.. Su autor ha proporcionado instrucciones detalladas sobre cómo usarlo. Debe saber cómo instalar las librerías de Python y ejecutar las secuencias de comandos de Python. Si no lo hace, he proporcionado una herramienta en línea en https://github.com/yihui/travis-exitwp. Puede cargar su archivo XML de WordPress allí y obtener un enlace de descarga a un archivo ZIP que contenga sus publicaciones en Markdown. El mayor desafío al convertir publicaciones de WordPress a Hugo es limpiar el contenido de la publicación en Markdown. Afortunadamente, he hecho esto para tres blogs de WordPress diferentes,39 Y creo que he logrado automatizar este proceso tanto como sea posible. Puede consultar el pull request que presenté a Karl Broman para convertir sus publicaciones de WordPress a Markdown (https://github.com/kbroman/oldblog_xml/pull/1), en las que proporcioné el guión en R y los archivos Markdown. Le recomiendo que vaya a la pestaña “Commits” y vea todos mis commit de GIT uno por uno para ver el proceso completo. La clave es el script en R https://github.com/yihui/oldblog_xml/blob/master/convert.R, que convierte el archivo XML de WordPress en publicaciones de Markdown y las limpia. Antes de ejecutar esta secuencia de comandos en su archivo XML, debe ajustar algunos parámetros, como el nombre del archivo XML, la URL de su sitio anterior de WordPress y la URL de su nuevo blog. Tenga en cuenta que este script depende de la herramienta Exitwp. Si no sabe cómo ejecutar Exitwp, utilice la herramienta en línea que mencioné anteriormente (travis-exitwp) y omita el código en R que llama a Exitwp. Las publicaciones de Markdown deben estar bastante limpias después de la conversión, pero puede haber etiquetas HTML restantes en sus publicaciones, como &lt;table&gt; y &lt;blockquote&gt;. Tendrá que limpiarlos manualmente, si existen. El blog de RViews (https://rviews.rstudio.com), el blog de RStudio (https://blog.rstudio.com) y el blog de Karl Broman (http://kbroman.org). El blog RViews me llevó unos días. El blog de RStudio me llevó un día. El blog de Karl Broman me llevó una hora.↩ "],
["desde-otros-sistemas.html", "4.3 Desde otros sistemas", " 4.3 Desde otros sistemas Si tiene un sitio web creado por otras aplicaciones o sistemas, su mejor opción es importar primero su sitio web a WordPress, exportarlo a Jekyll y limpiar los archivos Markdown. Puede intentar buscar soluciones sobre “cómo importar blogger.com a WordPress” o “cómo importar Tumblr a WordPress”. Si está familiarizado con las técnicas de web scrapping, también puede hacer scrape a las páginas HTML de su sitio web y convertirlas a Markdown a través de Pandoc, por ejemplo, rmarkdown::pandoc_convert( &#39;foo.html&#39;, to = &#39;markdown&#39;, output = &#39;foo.md&#39; ) De hecho, lo he intentado en un sitio web, pero no quedé satisfecho, ya que de todas formas tenía que limpiar mucho los archivos de Markdown. Si su sitio web es más simple, este enfoque puede funcionar mejor para usted. "],
["otros-generadores.html", "Capítulo 5 Otros generadores", " Capítulo 5 Otros generadores Mencionamos la posibilidad de evitar Hugo y usar su propio método de construcción en la sección D.9. Básicamente, tiene que construir el sitio usando blogdown::build_site(method=&quot;custom&quot;), y proporcionar su propio script de construcción /R/build.R. En este capítulo, le mostramos cómo trabajar con otros generadores de sitios estáticos populares como Jekyll y Hexo. Además de estos generadores de sitios estáticos escritos en otros idiomas, en realidad hay un generador de sitios simple escrito en R proporcionado en el paquete rmarkdown (Allaire et al. 2018), y lo presentaremos en la sección 5.3 References "],
["jekyll.html", "5.1 Jekyll", " 5.1 Jekyll Para los usuarios de Jekyll (https://jekyllrb.com)\\index{Jekyll}, he preparado un ejemplo mínimo en el repositorio de GitHub yihui/blogdown-jekyll.. Si clona o descarga este repositorio y abre blogdown-jekyll.Rproj en RStudio, puede usar todos los complementos mencionados en la sección 1.3, como “New Post”, &quot; Serve Site&quot; y “Update Metadata”, pero ahora es Jekyll en lugar de Hugo quien crea el sitio web tras bambalinas. Supongo que está familiarizado con Jekyll, y no voy a presentar los conceptos básicos de Jekyll en esta sección. Por ejemplo, debe saber lo que significan los directorios _posts/ y _site/. Las piezas clave de este proyecto blogdown-jekyll son los archivos .Rprofile, R/build.R, y R/build_one.R. He configurado algunas opciones en R globales para este proyecto en .Rprofile:40 options( blogdown.generator = &quot;jekyll&quot;, blogdown.method = &quot;custom&quot;, blogdown.subdir = &quot;_posts&quot; ) En primer lugar, el generador del sitio web se configuró en jekyll con la opción blogdown.generator, por lo que blogdown sabe que debe usar Jekyll para construir el sitio. En segundo lugar, el método de compilación blogdown.method se configuró como custom, por lo que podemos definir nuestro guión en R personalizado R/build.R para compilar los archivos Rmd (explicaré el motivo más adelante). En tercer lugar, el subdirectorio predeterminado para las nuevas publicaciones se estableció en _posts, que es la convención de Jekyll. Después de configurar esta opción, el complemento “New message” creará nuevas publicaciones en el directorio _posts/. Cuando la opción blogdown.method es custom, blogdown llamará al script R R/build.R para construir el sitio. Tiene plena libertad para hacer lo que quiera en este script. A continuación hay un script de ejemplo: build_one = function(io) { # si la salida no es más antigua que la entrada, omita la compilación if (!blogdown:::require_rebuild(io[2], io[1])) return() message(&#39;* knitting &#39;, io[1]) if (blogdown:::Rscript(shQuote(c(&#39;R/build_one.R&#39;, io))) != 0) { unlink(io[2]) stop(&#39;Failed to compile &#39;, io[1], &#39; to &#39;, io[2]) } } # Los archivos Rmd bajo el directorio raiz rmds = list.files(&#39;.&#39;, &#39;[.]Rmd$&#39;, recursive = T, full.names = T) files = cbind(rmds, xfun::with_ext(rmds, &#39;.md&#39;)) for (i in seq_len(nrow(files))) build_one(files[i, ]) system2(&#39;jekyll&#39;, &#39;build&#39;) Básicamente contiene una función build_one() que toma un argumento io, que es un vector de caracteres de longitud 2. El primer elemento es el nombre de archivo de entrada (Rmd) y el segundo elemento es el nombre del archivo de salida. Luego buscamos todos los archivos Rmd bajo el directorio actual, preparamos los nombres de los archivos de salida sustituyendo las extensiones de archivo Rmd por .md, y compilamos los archivos Rmd uno por uno. Tenga en cuenta que hay un mecanismo de almacenamiento en caché en build_one() que hace uso de una función interna de blogdown require_rebuild(). Esta función devuelve FALSE si el archivo de salida no es anterior al archivo de entrada en términos del tiempo de modificación. Esto puede ahorrarle algo de tiempo porque esos archivos Rmd que se han compilado anteriormente no se compilarán nuevamente cada vez. El paso clave en build_one() es ejecutar el script en R R/build_one.R, que explicaremos más adelante. Por último, creamos el sitio web a través de una llamada al sistema del comando jekyll build. El script R/build_one.R se ve así (he omitido algunas configuraciones no esenciales por simplicidad): local({ # fall back on &quot;/&quot; if baseurl is not specified baseurl = blogdown:::get_config2(&quot;baseurl&quot;, default = &quot;/&quot;) knitr::opts_knit$set(base.url = baseurl) knitr::render_jekyll() # set output hooks # input/output filenames as two arguments to Rscript a = commandArgs(TRUE) d = gsub(&quot;^_|[.][a-zA-Z]+$&quot;, &quot;&quot;, a[1]) knitr::opts_chunk$set( fig.path = sprintf(&quot;figure/%s/&quot;, d), cache.path = sprintf(&quot;cache/%s/&quot;, d) ) knitr::knit( a[1], a[2], quiet = TRUE, encoding = &quot;UTF-8&quot;, envir = globalenv() ) }) La secuencia de comandos se envuelve en local() para que un archivo Rmd se teja en un entorno global limpio, y las variables como baseurl, a y d no se crearán en el entorno global, es decir, globalenv() utilizado por knitr::knit() a continuación. La opción del paquete knitr base.url es una URL que se agregará previamente a las rutas de las figuras. Necesitamos configurar esta opción para asegurarnos de que las cifras generadas a partir de los fragmentos de código en R puedan encontrarse cuando se muestran en una página web. Una ruta de figura normal es a menudo como figure/foo.png, y puede no funcionar cuando la imagen se representa en un archivo HTML, porque figure/foo.png es una ruta relativa, y no hay garantía de que esto el archivo de imagen se copiará en el directorio del archivo HTML final. Por ejemplo, para un archivo fuente Rmd _posts/2015-07-23-hello.Rmd que genera figure/foo.png (en _posts/), el archivo HTML final puede ser _site/2015/07/23/hello/index.html. Jekyll sabe cómo renderizar un archivo HTML en esta ubicación, pero no entiende la dependencia de la imagen y no copiará el archivo de imagen en esta ubicación. Para resolver este problema, presentamos figuras en el directorio raíz /figure/, que Jekyll copiará a _site/. Para hacer referencia a una imagen en _site/figure/, necesitamos la barra diagonal (baseurl), por ejemplo, &lt;img src=&quot;/figure/foo.png&quot;&gt;. Esta es una ruta absoluta, por lo que no importa dónde se represente el HTML, esta ruta siempre funciona. Lo que knitr::render_jekyll() hace es principalmente configurar algunos hooks de salida knitr para que el código fuente y la salida de texto de los fragmentos de código en R se envuelvan en las etiquetas liquid {% highlight %} y {% end highlight %}. Recuerde que en build.R, pasamos la variable io a la llamada Rscript blogdown:::Rscript. Aquí en build_one.R, podemos recibirlos desde commandArgs(TRUE). La variable a contiene una ruta de archivo .Rmd y .md. Eliminamos el posible guion bajo principal (^_) y la extensión ([.] [a-zA-Z]$ en la ruta. A continuación, establecemos rutas de figura y caché utilizando esta cadena. Por ejemplo, para una publicación _posts/foo.Rmd, sus figuras se escribirán en figure/foo/ y sus bases de datos de caché (si las hay) se almacenarán bajo cache/foo/. Ambos directorios están bajo el directorio raíz del proyecto. Por último, llamamos a knitr::knit() para unir el archivo Rmd a un archivo de salida Markdown, que será procesado posteriormente por Jekyll. Una pequeña advertencia es que, dado que tenemos los dos archivos .Rmd y .md, Jekyll tratará ambos tipos de archivos como archivos Markdown de forma predeterminada. Tiene que pedirle a Jekyll que ignore los archivos .Rmd y que solo cree archivos .md. Puede establecer la opción exclude en _config.yml: exclude: [&#39;*.Rmd&#39;] Comparado con el soporte de Hugo en blogdown, este enfoque es limitado en algunos aspectos: No es compatible con Pandoc, por lo que no puede usar el Markdown de Pandoc. Como usa el paquete knitr en lugar de rmarkdown, tampoco puede usar ninguna de las funciones de Markdown blogdown. Usted está a merced de los renderizadores de Markdown apoyados por Jekyll. Sin rmarkdown, no puede usar widgets HTML. Básicamente, todo lo que puede tener es salida de texto dinámico y salida de gráficos en R a partir de fragmentos de código R. Pueden o no ser suficientes, dependiendo de sus casos de uso específicos. Es posible que podamos eliminar estas limitaciones en una versión futura de blogdown, si hay suficientes usuarios felices de Jekyll en la comunidad R. Si no está familiarizado con este archivo, lea la sección @ref(opciones globales).↩ "],
["hexo.html", "5.2 Hexo", " 5.2 Hexo Las ideas de usar Hexo (https://hexo.io) son muy similares a las que hemos aplicado a Jekyll en la sección anterior. También preparé un ejemplo mínimo en el repositorio de GitHub yihui/blogdown-hexo. Los componentes claves de este repositorio siguen siendo .Rprofile, R/build.R, y R/build_one.R. Establecimos la opción blogdown.generator en hexo, build.method en custom, y el subdirectorio predeterminado para las nuevas publicaciones en source/_posts. options( blogdown.generator = &#39;hexo&#39;, blogdown.method = &#39;custom&#39;, blogdown.subdir = &#39;source/_posts&#39; ) El script R/build.R es similar al del repositorio blogdown-jekyll. Las principales diferencias son: Encontramos todos los archivos Rmd bajo el directorio source/ en lugar del directorio raíz, porque la convención de Hexo es poner todos los archivos fuente bajo source/. Llamamos system2('hexo', 'generate') para construir el sitio web. Para el script R/build_one.R, la principal diferencia con el script en el repositorio blogdown-jekyll es que establecemos la opción base.dir para knitr, de modo que se generan todas las figuras en R al directorio fuente/. Esto se debe a que Hexo copia todo bajo source/ a public/, mientras que Jekyll copia todo bajo el directorio raíz a _site/. local({ # fall back on &#39;/&#39; if baseurl is not specified baseurl = blogdown:::get_config2(&#39;root&#39;, &#39;/&#39;) knitr::opts_knit$set( base.url = baseurl, base.dir = normalizePath(&#39;source&#39;) ) # input/output filenames as two arguments to Rscript a = commandArgs(TRUE) d = gsub(&#39;^source/_?|[.][a-zA-Z]+$&#39;, &#39;&#39;, a[1]) knitr::opts_chunk$set( fig.path = sprintf(&#39;figure/%s/&#39;, d), cache.path = sprintf(&#39;cache/%s/&#39;, d) ) knitr::knit( a[1], a[2], quiet = TRUE, encoding = &#39;UTF-8&#39;, envir = .GlobalEnv ) }) Este repositorio también se crea automáticamente y se implementa a través de Netlify cuando le envío cambios. Como Hexo es un paquete de Node y Netlify es compatible con Node, puede instalar Hexo fácilmente en Netlify. Por ejemplo, este repositorio de ejemplo usa el comando npm install &amp;&amp; hexo generate para construir el sitio web; npm install instalará los paquetes de Node especificados en packages.json (un archivo bajo el directorio raíz del repositorio), y hexo generate es el comando para construir el sitio web desde source/ a public/. "],
["rmd-website.html", "5.3 Generados del sitio web por defecto en rmarkdown", " 5.3 Generados del sitio web por defecto en rmarkdown Antes de que se inventara blogdown, en realidad existía una forma relativamente simple de hacer sitios web usando rmarkdown. La estructura del sitio web debe ser un directorio plano de archivos Rmd (sin subdirectorios para archivos Rmd) y un archivo de configuración en el que puede especificar una barra de navegación para todas sus páginas y opciones de formato de salida. Puede encontrar más información sobre este generador de sitios en su documentación en http://rmarkdown.rstudio.com/rmarkdown_websites.html, y no vamos a repetir la documentación aquí, solo queremos destacar las principales diferencias entre el sitio predeterminado generador en rmarkdown y otros generadores de sitios especializados como Hugo: El generador de sitios rmarkdown requiere que todos los archivos Rmd estén bajo el directorio raíz. Hugo no tiene restricciones en la estructura del sitio, y puede crear directorios y archivos arbitrarios bajo /content/. Hugo es un generador de sitios de uso general altamente personalizable, y hay muchas cosas que el generador de sitios predeterminado de rmarkdown no admite, por ejemplo, fuentes RSS, metadatos especialmente comunes en blogs como categorías y etiquetas, y la personalización de enlaces permanentes para ciertas páginas. Todavía hay razones legítimas para elegir el generador de sitios predeterminado rmarkdown, aunque no parece ser tan poderoso como Hugo, incluyendo: Está familiarizado con generar resultados HTML de una sola página a partir de R Markdown, y todo lo que desea es ampliar esto para generar varias páginas a partir de múltiples archivos Rmd. Basta usar un directorio plano de archivos Rmd. No escribe un blog o necesita fuentes RSS. Prefiere los estilos Bootstrap. En teoría, también puede aplicar estilos de Bootstrap a los sitios web de Hugo, pero requerirá que aprenda más sobre Hugo. Bootstrap tiene un buen soporte en rmarkdown, y puede dedicar más tiempo a las configuraciones en lugar de aprender los detalles técnicos sobre cómo funciona. Hay ciertas características en la salida de rmarkdown HTML que faltan en blogdown. Por ejemplo, actualmente no puede imprimir cuadros de datos fácilmente como tablas paginadas, agregar una tabla de contenido flotante o doblar/desplegar bloques de código dinámicamente en la salida de blogdown. Todo esto podría implementarse a través de JavaScript y CSS, pero ciertamente no es tan simple como especificar algunas opciones en rmarkdown como toc_float: true. Tenga en cuenta que el generador de sitios rmarkdown también es extensible. Por ejemplo, el paquete bookdown (Xie 2018a) es esencialmente un generador de sitios personalizado para generar libros como sitios web. References "],
["pkgdown.html", "5.4 pkgdown", " 5.4 pkgdown El paquete pkgdown ((???), https://github.com/hadley/pkgdown) puede ayudarlo a convertir rápidamente la documentación R de un paquete en R (incluidas páginas de ayuda y viñetas) en un sitio web. Es independiente de blogdown y resuelve un problema específico. No es un generador de sitios web de propósito general. Queremos mencionarlo en este libro porque es muy fácil de usar y también muy útil. Puede encontrar las instrucciones en su sitio web o en su repositorio de GitHub. "],
["r-markdown.html", "A R Markdown", " A R Markdown R Markdown (???) es un formato de documento de texto plano que consta de dos componentes: R (u otros lenguajes de cálculo) y Markdown. Markdown hace que sea fácil para los autores escribir un documento debido a su sintaxis simple. El código de programa (como el código en R) se puede incrustar en un documento de origen Markdown para generar un documento de salida directamente: al compilar el documento fuente, se ejecutará el código del programa y su salida se mezclará con el texto Markdown. Los archivos de R Markdown generalmente usan la extensión de nombre de archivo .Rmd. A continuación se muestra un ejemplo mínimo: --- title: Una regresión lineal simple author: Yihui Xie --- A continnuación, construimos una regresión lineal. ```{r} fit = lm(dist ~ speed, data = cars) b = coef(summary(fit)) plot(fit) ``` La pendiente de la regresión es `r b[2, 1]`. Dicho documento se puede compilar usando la función rmarkdown::render(), o lo que es lo mismo, haciendo clic en el botón Knit en RStudio. Tras bambalinas, un documento de R Markdown se compila primero a Markdown por knitr (Xie 2018b), que ejecuta todos los códigos del programa en el documento. Luego, el documento de salida de Markdown se compila en el documento de salida final a través de Pandoc, como una página HTML, un documento PDF, un documento de Word, etc. Es importante conocer este proceso de dos pasos; de lo contrario, es posible que no sepa qué documentación del paquete buscar cuando tenga preguntas. Básicamente, para todo lo relacionado con los fragmentos del código (R), consulte la documentación knitr (https://yihui.name/knitr/); para cualquier cosa relacionada con Markdown, consulte la documentación de Pandoc (https://pandoc.org). Un documento de R Markdown normalmente consta de metadatos YAML (opcional) y el cuerpo del documento. Los metadatos YAML se escriben entre un par de --- para establecer algunos atributos del documento, como el título, el autor y la fecha, etc. En el cuerpo del documento, puede mezclar fragmentos de código y párrafos. Un bloque de código comienza con un encabezado de fragmento ```{r} y termina con ```. Hay muchas opciones de fragmentos posibles que puede establecer en el encabezado del fragmento para controlar la salida, por ejemplo, puede establecer la altura de la figura en 4 pulgadas con ```{r fig.height = 4}. Para ver todas las opciones de fragmentos posibles, consulte https://yihui.name/knitr/options/. Pandoc admite una gran variedad de formatos de documentos de salida. Para blogdown, el formato de salida se establece en HTML (blogdown::html_page), ya que un sitio web normalmente consta de páginas HTML. Si desea otros formatos, consulte la sección ??. Para crear una publicación de R Markdown para blogdown, se recomienda que utilice “New post” de RStudio (Figura @ref(fig: new-post)) o la función blogdown::new_post(), en lugar del menú de RStudio File -&gt; New File -&gt; R Markdown. Le recomendamos que revise la documentación de las opciones de chunk knitr y el manual de Pandoc al menos una vez para tener una idea de todas las posibilidades. Los conceptos básicos de Markdown son bastante simples, pero también hay muchas características menos conocidas en Markdown de Pandoc. Como mencionamos en la sección @ref(formato de salida), el formato de salida de blogdown se basa en bookdown (Xie 2018a), que contiene varias otras extensiones de Markdown, como ecuaciones numeradas y entornos de teoremas, y debe leer el Capítulo 2 del libro bookdown (Xie 2016) para obtener más información sobre estas características. Puede encontrar una hoja de referencia de R Markdown y una guía de referencia en https://www.rstudio.com/resources/cheatsheets/, que puede ser útil una vez que esté más familiarizado con R Markdown. Con R Markdown, solo necesita mantener los documentos fuente; todas las páginas de salida se pueden generar automáticamente a partir de documentos fuente. Esto hace que sea mucho más fácil mantener un sitio web, especialmente cuando el sitio web está relacionado con el análisis de datos o con la informática estadística y los gráficos. Cuando se actualiza el código fuente (por ejemplo, el modelo o los datos se cambian), en consecuencia, sus páginas web se pueden actualizar y automáticamente. No es necesario ejecutar el código por separado y cortar y pegar de nuevo. Además de la comodidad, obtiene reproducibilidad al mismo tiempo. References "],
["conceptos-basicos-de-sitios-web.html", "B Conceptos básicos de sitios web", " B Conceptos básicos de sitios web Si desea ajustar el aspecto de su sitio web, o incluso diseñar su propio tema, debe tener algunos conocimientos básicos de desarrollo web. En este apéndice, presentamos brevemente HTML, CSS y JavaScript, que son los componentes más comunes de una página web, aunque CSS y JavaScript son opcionales. Nuestro objetivo es comenzar con HTML, CSS y JavaScript. HTML es relativamente fácil de aprender, pero CSS y JavaScript pueden ser mucho más complicados, dependiendo de cuánto quiera aprender y qué quiera hacer con ellos. Después de leer este apéndice, deberá usar otros recursos para aprender. Cuando busca estas tecnologías en línea, los sitios web más probables a los que puede acceder son MDN (Mozilla Developer Network), w3schools.com, y StackOverflow.. Entre estos sitios web, w3schools a menudo proporciona ejemplos simples y tutoriales que pueden ser más amigables para los principiantes, pero a menudo escuchamos comentarios negativos al respecto, por lo tanto, úselo con precaución. A menudo leo los tres sitios web cuando busco soluciones. Si solo pudiéramos dar un consejo más útil sobre el desarrollo web, sería: use las herramientas de desarrollo de su navegador web. La mayoría de los navegadores web modernos ofrecen estas herramientas. Por ejemplo, puede encontrar estas herramientas en el menú de Google Chrome Ver -&gt; Desarrollador, el menú de Firefox Herramientas -&gt; Desarrollador web, o el menú ‘Desarrollar -&gt; Mostrar inspector web’ de Safari. La figura @ref(fig: chrome-devtools) es una captura de pantalla del uso de Herramientas de desarrollador en Chrome. FIGURA B.1: Herramientas de desarrollador en Google Chrome. Por lo general, también puede abrir las Herramientas de desarrollo haciendo clic derecho en un elemento determinado en la página web y seleccionando la opción del menú Inspeccionar (o Inspeccionar elemento). En la figura @ref(fig: chrome-devtools), hice clic derecho en la imagen de perfil de mi sitio web https://yihui.name y lo inspeccioné, y Chrome destacó su código fuente HTML &lt;img src=&quot;...&quot;.../&gt; en el panel izquierdo. También puede ver los estilos CSS asociados con este elemento img en el panel derecho. Además, puede cambiar los estilos de forma interactiva si conoce CSS y ver los efectos (temporales) en tiempo real en la página. Una vez que esté satisfecho con los nuevos estilos, puede escribir el código CSS en los archivos. Hay muchas características increíbles de Herramientas de desarrollador, que las hacen no solo extremadamente útiles para la depuración y la experimentación, sino también útiles para el aprendizaje del desarrollo web. Estas herramientas son indispensables para mí cuando desarrollo algo relacionado con páginas web. Aprendí mucho sobre CSS y JavaScript jugando con estas herramientas. "],
["html.html", "B.1 HTML", " B.1 HTML HTML significa Hyper Text Markup Language, y es el lenguaje detrás de la mayoría de las páginas web que usted ve. Puede usar el menú Ver -&gt; Ver fuente o el menú contextual Ver fuente de página para ver la fuente HTML completa de una página web en su navegador. Todos los elementos en una página están representados por etiquetas HTML. Por ejemplo, la etiqueta &lt;p&gt; representa párrafos, y &lt;img&gt; representa imágenes. Lo bueno de HTML es que el lenguaje tiene solo un número limitado de etiquetas, y el número no es muy grande (especialmente el número de etiquetas comúnmente utilizadas). Esto significa que hay esperanza de que pueda dominar este idioma de manera completa y rápida. La mayoría de las etiquetas HTML aparecen en pares, con una etiqueta de apertura y una etiqueta de cierre, por ejemplo, &lt;p&gt;&lt;/p&gt;. Usted escribe el contenido entre las etiquetas de apertura y cierre, por ejemplo, &lt;p&gt;Este es un párrafo.&lt;/ P&gt;. Hay algunas excepciones, como la etiqueta &lt;img&gt;, que se puede cerrar con una barra inclinada / en la etiqueta de apertura, por ejemplo, &lt;img src=&quot;foo.png&quot;/&gt;. Puede especificar los atributos de un elemento en la etiqueta de apertura usando la sintaxis name=value (algunos atributos no requieren value). Los documentos HTML a menudo tienen la extensión de nombre de archivo .html (o .htm). A continuación se muestra una estructura general de un documento HTML: &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; Básicamente, un documento HTML consta de una sección head y body. Puede especificar los metadatos e incluir archivos como archivos CSS en la sección head. Normalmente, la sección head no está visible en una página web. Es la sección de ‘cuerpo’ que mantiene el contenido para mostrarse a un lector. A continuación se muestra un documento de ejemplo un poco más rico: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Your Page Title&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/style.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;A First-level Heading&lt;/h1&gt; &lt;p&gt;A paragraph.&lt;/p&gt; &lt;img src=&quot;/images/foo.png&quot; alt=&quot;A nice image&quot; /&gt; &lt;ul&gt; &lt;li&gt;An item.&lt;/li&gt; &lt;li&gt;Another item.&lt;/li&gt; &lt;li&gt;Yet another item.&lt;/li&gt; &lt;/ul&gt; &lt;script src=&quot;/js/bar.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; En la cabecera, declaramos que la codificación de caracteres de esta página es UTF-8 a través de una etiqueta &lt;meta&gt;, especificamos el título mediante la etiqueta &lt;title&gt; e incluimos una hoja de estilo mediante una etiqueta &lt;link&gt;. El cuerpo contiene un encabezado de sección de primer nivel &lt;h1&gt;,41 Un párrafo &lt;p&gt;, una imagen &lt;img&gt;, una lista desordenada &lt;ul&gt; con tres elementos de lista &lt;li&gt;, e incluye un archivo JavaScript al final a través de &lt;script&gt;. Hay tutoriales mucho mejores en HTML que esta sección, como los que ofrecen MDN y w3schools.com, por lo que no vamos a hacer de esta sección un tutorial completo. En cambio, solo queremos brindar algunos consejos sobre HTML: Puede validar su código HTML a través de este servicio: https://validator.w3.org. Este validador señalará posibles problemas de su código HTML. En realidad, también funciona para documentos XML y SVG. Entre todos los atributos de HTML, las rutas de archivos (el atributo src de algunas etiquetas como &lt;img&gt;) y los enlaces (el atributo href de la etiqueta &lt;a&gt;) pueden ser las más confusas para los principiantes. Las rutas y los enlaces pueden ser relativos o absolutos, y pueden venir con o sin el protocolo y el dominio. Tiene que entender a qué apunta exactamente un enlace o una ruta. Un enlace completo tiene la forma http://www.example.com/foo/bar.ext, donde http especifica el protocolo (puede tratarse de otros protocolos como https o ftp), www.example.com es el dominio, y foo/bar.ext es el archivo debajo del directorio raíz del sitio web. Si se refiere a recursos en el mismo sitio web (el mismo protocolo y dominio), le recomendamos que omita el protocolo y los nombres de dominio, para que los enlaces continúen funcionando incluso si cambia el protocolo o dominio. Por ejemplo, un enlace &lt;a href=&quot;/hi/there.html&quot;&gt; en una página http://example.com/foo/ hace referencia a http://example.com/hi/there.html. No importa si cambia http a https, o example.com a another-domain.com. Dentro del mismo sitio web, un enlace o ruta puede ser relativa o absoluta. El significado de una ruta absoluta no cambia sin importar dónde se coloca el archivo HTML actual, pero el significado de una ruta relativa depende de la ubicación del archivo HTML actual. Supongamos que está viendo la página example.com/hi/there.html: Una ruta absoluta /foo/bar.ext siempre significa example.com/foo/bar.ext. La barra diagonal significa el directorio raíz del sitio web. Una ruta relativa ../images/foo.png significa example.com/images/foo.png (.. significa subir un nivel). Sin embargo, si el archivo HTML there.html se mueve a example.com/hey/again/there.html, esta ruta en there.html se referirá a example.com/hey/images/foo.png. Cuando decida si usar rutas relativas o absolutas, aquí está la regla general: si no va a mover los recursos referidos o vinculados de un subpath a otro (por ejemplo, de example.com/foo/ a example.com/bar/), pero solo mueve las páginas HTML que usan estos recursos, usa rutas absolutas; Si desea cambiar el subpaso de la URL de su sitio web, pero las ubicaciones relativas de los archivos HTML y los recursos que utilizan no cambian, puede usar enlaces relativos (por ejemplo, puede mover todo el sitio web de example.com/ a example.com/foo/). Si los conceptos anteriores parecen demasiado complicados, una mejor manera es pensar detenidamente sobre la estructura de su sitio web y evitar mover archivos, o usar reglas de redireccionamientos si son compatibles (como los redireccionamientos 301 o 302). Si enlaza a un sitio web o página web diferente, debe incluir el dominio en el enlace, pero puede no ser necesario incluir el protocolo, por ejemplo, //test.example.com/foo.css es un ruta válida. El protocolo real de esta ruta coincide con el protocolo de la página actual, por ejemplo, si la página actual es https://example.com/, este enlace significa https://test.example.com/foo.css. Puede ser beneficioso omitir el protocolo porque los recursos HTTP no se pueden incrustar en páginas servidas a través de HTTPS (por razones de seguridad), por ejemplo, una imagen en http://example.com/foo.png no se puede incrustar en una página https://example.com/hi.html via &lt;img src=&quot;http://example.com/foo.png&quot;/&gt;, pero &lt;img src=&quot;//example.com/foo.png&quot;/&gt; funcionará si se puede acceder a la imagen a través de HTTPS, es decir, https://example.com/foo.png. El principal inconveniente de no incluir el protocolo es que tales enlaces y rutas no funcionan si abre el archivo HTML localmente sin usar un servidor web, por ejemplo, solo haga doble clic en el archivo HTML en su buscador de archivos y muéstrelo en el navegador.42 Un error muy común que las personas cometen es poner un enlace sin las dobles barras delanteras delante del dominio. Puede pensar que www.example.com es un enlace válido. ¡No lo es! Al menos no se vincula al sitio web al que desea vincularse. Funciona cuando lo escribe en la barra de direcciones de su navegador porque su navegador normalmente lo autocompletará en http://www.example.com. Sin embargo, si escribe un enlace &lt;a href=&quot;www.example.com&quot;&gt;Vea este enlace&lt;/a&gt;, tendrá problemas. El navegador interpretará esto como un enlace relativo, y es relativo a la URL de la página web actual, por ejemplo, si actualmente está viendo http://yihui.name/cn/, el enlace www.example.com en realidad significa http://yihui.name/cn/www.example.com! Ahora debería conocer el texto de Markdown [Link](www.example.com) suele ser un error, a menos que realmente quiera vincular un subdirectorio de la página actual o un archivo con literalmente el nombre www.example.com. Hay seis niveles posibles de h1, h2, …, a h6.↩ Eso es porque sin un servidor web, un archivo HTML se ve a través del protocolo archivo. Por ejemplo, puede ver una URL del formulario file://ruta/al/archivo.html en la barra de direcciones de su navegador. La ruta //example.com/foo.png se interpretará como file://example.com/foo.png, que es poco probable que exista como un archivo local en su computadora.↩ "],
["css.html", "B.2 CSS", " B.2 CSS El lenguaje Cascading Stylesheets (CSS) se utiliza para describir el aspecto y el formato de los documentos escritos en HTML. CSS es responsable del estilo visual de su sitio. CSS es muy divertido de jugar, pero también puede robar tu tiempo fácilmente. En el marco de Hugo (https://gohugo.io/tutorials/creating-a-new-theme/), CSS es uno de los principales archivos “sin contenido” que da forma a la apariencia de su sitio (los otros son imágenes, JavaScript y plantillas Hugo). ¿Qué significa el “aspecto y tacto” de un sitio? “Buscar” generalmente se refiere a componentes de estilo estático que incluyen, entre otros, paltetas de color, imágenes, diseños/márgenes, y fuentes. mientras que “sentir” se relaciona con componentes dinámicos con los que el usuario interactúa como menús desplegables, botones, y formas. Hay 3 formas de definir estilos. El primero está en línea con HTML. Por ejemplo, este código &lt;p&gt;Marco! &lt;em&gt;Polo!&lt;/em&gt;&lt;/p&gt; produciría texto que se parece a esto: Marco! Polo! Sin embargo, este método generalmente no es preferido para razones numerosas. Una segunda forma es definir internamente el CSS colocando una sección de estilo en su HTML: &lt;html&gt; &lt;style&gt; #favorite { font-style: italic; } &lt;/style&gt; &lt;ul id=&quot;tea-list&quot;&gt; &lt;li&gt;Earl Grey&lt;/li&gt; &lt;li&gt;Darjeeling&lt;/li&gt; &lt;li&gt;Oolong&lt;/li&gt; &lt;li&gt;Chamomile&lt;/li&gt; &lt;li id=&quot;favorite&quot;&gt;Chai&lt;/li&gt; &lt;/ul&gt; &lt;/html&gt; En este ejemplo, solo el último té enumerado, Chai, está en cursiva. El tercer método es el más popular porque es más flexible y el menos repetitivo. En este método, usted define el CSS en un archivo externo que luego se referencia como un enlace en su HTML: &lt;html&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/style.css&quot; /&gt; &lt;/html&gt; Lo que va dentro del documento CSS vinculado es esencialmente una lista de reglas (la misma lista podría aparecer internamente entre las etiquetas de estilo, si está utilizando el segundo método). Cada regla debe incluir un selector o un grupo de selectores, y un bloque de declaraciones dentro de llaves que contenga uno o más pares property: value;. Aquí está la estructura general para una regla: /* CSS pseudo-code */ selectorlist { property: value; /* more property: value; pairs*/ } Los selectores pueden basarse en tipos o atributos de elementos HTML, como id o class (y combinaciones de estos atributos): /* by element type */ li { color: yellow; /* all &lt;li&gt; elements are yellow */ } /* by ID with the # symbol */ #my-id { color: yellow; /* elements with id = &quot;my-id&quot; are yellow */ } /* by class with the . symbol */ .my-class { color: yellow; /* elements with class = &quot;my-class&quot; are yellow */ } Debido a que cada elemento HTML puede coincidir con varios selectores diferentes, el estándar CSS determina qué conjunto de reglas tiene prioridad para cualquier elemento dado y qué propiedades heredar. Aquí es donde el algoritmo de cascada entra en juego. Por ejemplo, tome una lista desordenada simple: &lt;ul id=&quot;tea-list&quot;&gt; &lt;li&gt;Earl Grey&lt;/li&gt; &lt;li&gt;Darjeeling&lt;/li&gt; &lt;li&gt;Oolong&lt;/li&gt; &lt;li&gt;Chamomile&lt;/li&gt; &lt;li&gt;Chai&lt;/li&gt; &lt;/ul&gt; Ahora, digamos que queremos resaltar nuestros tés favoritos nuevamente, así que usaremos un atributo de clase. &lt;ul id=&quot;tea-list&quot;&gt; &lt;li&gt;Earl Grey&lt;/li&gt; &lt;li class=&quot;favorite&quot;&gt;Darjeeling&lt;/li&gt; &lt;li&gt;Oolong&lt;/li&gt; &lt;li&gt;Chamomile&lt;/li&gt; &lt;li class=&quot;favorite&quot;&gt;Chai&lt;/li&gt; &lt;/ul&gt; Podemos usar este atributo de clase como un selector en nuestro CSS. Digamos que queremos que nuestros tés favoritos estén en negrita y tengan un color de fondo amarillo, por lo que nuestro CSS se vería así: .favorite { font-weight: bold; background-color: yellow; } Ahora, si desea que cada elemento de la lista se ponga en cursiva con un fondo blanco, puede configurar otra regla: li { font-style: italic; background-color: white; } Si juega con este código (que puede usar fácilmente usando sitios como http://jsbin.com, https://jsfiddle.net o https://codepen.io/pen/), verá que el segundo té favorito sigue resaltado en amarillo. Esto se debe a que la regla de CSS sobre .favorite como clase es más específica que la regla sobre elementos de tipo li. Para anular la regla .favorite, debe ser tan específico como sea posible al elegir su grupo de selectores: ul#tea-list li.favorite { background-color: white; } Este ejemplo solo araña la superficie de cascada y herencia. Para cualquier tema de Hugo que instale, puede encontrar el archivo CSS en la carpeta themes/. Por ejemplo, el tema predeterminado de litio se encuentra en: themes/hugo-lithium-theme/static/css/main.css. Una vez que esté familiarizado con CSS, puede comprender cómo funciona cada conjunto de reglas para dar forma al estilo visual de su sitio web, y cómo modificar las reglas. Para algunos temas (es decir, el tema académico), tiene la opción de vincular a un CSS personalizado que puede utilizar para personalizar aún más el estilo visual de su sitio. Algunos ejemplos de una línea ilustran cómo las simples reglas de CSS se pueden usar para hacer cambios dramáticos: Para hacer imágenes circulares o redondeadas, puede asignar una clase img-circle a imágenes (e.g., &lt;img class=&quot;img-circle&quot; src=&quot;foo.png&quot; /&gt;) y definir el CSS: .img-circle { border-radius: 50%; } Para hacer tablas de rayas, puede agregar colores de fondo a las filas impares o pares de la tabla, e.g., tr:nth-child(even) { background: #eee; } Puede agregar o anteponer contenido a elementos a través de pseudo-elementos ::after y ::before. Aquí hay un ejemplo de cómo agregar un período después de los números de sección: https://github.com/rstudio/blogdown/issues/80. "],
["javascript.html", "B.3 JavaScript", " B.3 JavaScript Es mucho más difícil introducir JavaScript que HTML y CSS, ya que es un lenguaje de programación. Hay muchos libros y tutoriales sobre este idioma. De todos modos, intentaremos arañar la superficie para los usuarios R en esta sección. En pocas palabras, JavaScript es un lenguaje que generalmente se utiliza para manipular elementos en una página web. Una forma efectiva de aprender es a través de la consola de JavaScript en las Herramientas de Desarrollador de su navegador web (vea la Figura @ref(fig: chrome-devtools)), porque puede escribir código de manera interactiva en la consola y ejecutarlo, lo cual se siente similar para ejecutar el código en R en la consola de R (por ejemplo, en RStudio). Puede abrir cualquier página web en su navegador web (por ejemplo, https://yihui.name), luego abrir la consola de JavaScript y probar el siguiente código en cualquier página web: document.body.style.background = &#39;orange&#39;; Debería cambiar el color de fondo de la página a naranja, a menos que la página ya haya definido los colores de fondo para ciertos elementos. Para usar JavaScript de manera efectiva, debe aprender tanto la sintaxis básica de JavaScript como la forma de seleccionar elementos en una página antes de poder manipularlos. Puede aprender parcialmente lo primero a partir del fragmento corto de JavaScript a continuación: var x = 1; // assignments 1 + 2 - 3 * 4 / 5; // arithmetic if (x &lt; 2) console.log(x); // &quot;print&quot; x var y = [9, 1, 0, 2, 1, 4]; // array // function var sum = function(x) { var s = 0; // a naive way to compute the sum for (var i=0; i &lt; x.length; i++) { s += x[i]; } return s; }; sum(y); var y = &quot;Hello World&quot;; y = y.replace(&quot; &quot;, &quot;, &quot;); // string manipulation Puede sentir que la sintaxis es similar a R hasta cierto punto. JavaScript es un lenguaje orientado a objetos, y generalmente hay varios métodos que puede aplicar a un objeto. La manipulación de cadena anterior es un ejemplo típico de la sintaxis Object.method(). Para conocer los métodos posibles en un objeto, puede escribir el nombre del objeto en su consola JavaScript seguido de un punto, y debería ver todos los candidatos. Los usuarios de R deben ser extremadamente cautelosos porque los objetos JavaScript a menudo son mutables, lo que significa que un objeto puede ser modificado en cualquier lugar. A continuación, hay un ejemplo rápido: var x = {&quot;a&quot;: 1, &quot;b&quot;: 2}; // como una lista en R var f = function(z) { z.a = 100; }; f(x); x; // modificado! x.a es 100 ahora Hay muchas librerías maduras de JavaScript que pueden ayudarlo a seleccionar y manipular elementos en una página, y la más popular puede ser jQuery. Sin embargo, debe saber que a veces probablemente puede hacerlo lo suficientemente bien sin estas librerías de terceros. Hay algunos métodos básicos para seleccionar elementos, como document.getElementById() y document.getElementsByClassName(). Por ejemplo, puede seleccionar todos los párrafos usando document.querySelectorAll('p'). A continuación mostramos una aplicación ligeramente avanzada, en la que verá funciones anónimas, selección de elementos por nombres de etiquetas HTML, expresiones regulares y manipulación de elementos HTML. En la sección 2.5.2, mencionamos cómo habilitar MathJax en un sitio web de Hugo. La parte fácil es incluir el script MathJax.js a través de una etiqueta &lt;script&gt;, y hay dos partes difíciles: Cómo proteger el contenido matemático del motor de reducción (Blackfriday), por ejemplo, necesitamos asegurarnos de que los subrayados en las expresiones matemáticas no se interpreten como &lt;em&gt;&lt;/em&gt;. Este problema solo existe en las publicaciones simples de Markdown, y se ha mencionado en la sección ?? sin explicar la solución. Por defecto, MathJax no reconoce un par de signos de pesos como la sintaxis de las expresiones matemáticas en línea, pero la mayoría de los usuarios se sienten más cómodos con la sintaxis $x$ que con \\(x\\). La solución más fácil para el primer problema puede ser la adición de retrocesos alrededor de las expresiones matemáticas, por ejemplo, `$x_i$`, pero la consecuencia es que la expresión matemática se representará en &lt;code&gt;&lt;/code&gt;, y MathJax ignora las etiquetas &lt;code&gt; cuando busca expresiones matemáticas en la página. Podemos obligar a MathJax a buscar expresiones matemáticas en &lt;code&gt;, pero esto seguirá siendo problemático. Por ejemplo, alguien puede querer mostrar el código en línea R `list$x$y`, y $x$ puede reconocerse como una expresión matemática. MathJax ignora &lt;code&gt; por buenas razones. Incluso si no tiene esas expresiones en &lt;code&gt;, puede tener algunos estilos CSS especiales adjuntos a &lt;code&gt;, y estos estilos se aplicarán a sus expresiones matemáticas, que pueden ser no deseadas (por ejemplo, una luz fondo gris). Para resolver estos problemas, proporcioné una solución en el código JavaScript en https://yihui.name/js/math-code.js: (function() { var i, text, code, codes = document.getElementsByTagName(&#39;code&#39;); for (i = 0; i &lt; codes.length;) { code = codes[i]; if (code.parentNode.tagName !== &#39;PRE&#39; &amp;&amp; code.childElementCount === 0) { text = code.textContent; if (/^\\$[^$]/.test(text) &amp;&amp; /[^$]\\$$/.test(text)) { text = text.replace(/^\\$/, &#39;\\\\(&#39;).replace(/\\$$/, &#39;\\\\)&#39;); code.textContent = text; } if (/^\\\\\\((.|\\s)+\\\\\\)$/.test(text) || /^\\\\\\[(.|\\s)+\\\\\\]$/.test(text) || /^\\$(.|\\s)+\\$$/.test(text) || /^\\\\begin\\{([^}]+)\\}(.|\\s)+\\\\end\\{[^}]+\\}$/.test(text)) { code.outerHTML = code.innerHTML; // remove &lt;code&gt;&lt;/code&gt; continue; } } i++; } })(); No es una solución perfecta, pero debería ser muy raro que tenga problemas. Esta solución identifica posibles expresiones matemáticas en &lt;code&gt;, y elimina la etiqueta &lt;code&gt;, por ejemplo, reemplaza &lt;code&gt;$x$&lt;/code&gt; con \\(x\\). Después de que se ejecuta este script, cargamos el script MathJax. De esta forma, no necesitamos obligar a MathJax a buscar expresiones matemáticas en las etiquetas &lt;code&gt;, y sus expresiones matemáticas no heredarán ningún estilo de &lt;code&gt;. El código de JavaScript anterior no es demasiado largo y debe ser autoexplicativo. La parte más difícil es i++. Dejaré que los lectores descubran por qué el bucle for no es la forma habitualfor(i = 0; i &lt;codes.length; i ++). Me tomó unos minutos darme cuenta de mi error cuando escribí el ciclo en la forma habitual. "],
["recursos-utiles.html", "B.4 Recursos útiles", " B.4 Recursos útiles B.4.1 Organización de archivos Aunque los sitios web estáticos de son rápidos en general, ciertamente puede optimizarlos aún más. Puede buscar “minificador de CSS y JavaScript”, y estas herramientas pueden comprimir sus archivos CSS y JavaScript, de modo que puedan cargarse más rápido. Como hay muchas herramientas, no las recomendaré aquí. También puede optimizar imágenes en su sitio web. Frecuentemente uso una herramienta de línea de comandos llamada optipng para optimizar las imágenes PNG. Es un optimizador sin pérdida, lo que significa que reduce el tamaño del archivo de una imagen PNG sin pérdida de calidad. Desde mi experiencia, funciona muy bien en imágenes PNG generadas a partir de R, y puede reducir el tamaño del archivo en al menos un 30% (a veces incluso más del 50%). Personalmente también uso herramientas en línea como http://optimizilla.com para optimizar imágenes PNG y JPEG. Para imágenes GIF, a menudo uso https://ezgif.com/optimize para reducir el tamaño de los archivos si son demasiado grandes. Tenga en cuenta que Netlify ha proporcionado las funciones de optimización en el servidor de forma gratuita en este momento, por lo que es posible que desee habilitarlos allí en lugar de hacer todo el trabajo por su cuenta. B.4.2 Ayudando a las personas a encontrar su sitio Una vez que su sitio esté en funcionamiento, es probable que desee que las personas lo encuentren. SEO — Search Engine Optimization — es el arte de hacer que un sitio web sea fácil de entender para los motores de búsqueda como Google. Y, con suerte, si el motor de búsqueda sabe de lo que está escribiendo, presentará enlaces a su sitio con altos resultados cuando alguien busque los temas que cubre. Se han escrito libros completos sobre SEO, sin mencionar las muchas empresas que se dedican a ofrecer asesoramiento técnico y estratégico (pagado) para ayudar a que los sitios estén en la cima de los rankings de los motores de búsqueda. Si está interesado en obtener más información, un buen lugar para comenzar es la Guía de inicio de la optimización del motor de búsqueda de Google (http://bit.ly/google-seo-starter). A continuación hay algunos puntos clave: El título que seleccione para cada página y publicación es una señal muy importante para Google y otros motores de búsqueda que les dicen de qué se trata esa página. Las etiquetas de descripción también son fundamentales para explicar de qué se trata una página. En documentos HTML, etiquetas de descripción son una forma de proporcionar metadatos sobre la página. Con blogdown, la descripción puede terminar como texto debajo del título de la página en un resultado de motor de búsqueda. Si el YAML de su página no incluye una descripción, puede agregar uno como description:&quot;Una breve descripción de esta página.&quot;; la fuente HTML de la página renderizada tendría una etiqueta &lt;meta&gt; en &lt;head&gt; como &lt;meta name=&quot;description&quot; content=&quot; Una breve descripción de esta página.&quot;&gt;. No todos los temas admiten agregar la descripción a su página HTML (¡aunque deberían!) La estructura de URL también es importante. Desea que el slug de su publicación tenga palabras clave informativas, lo que le da otra señal de lo que trata la página. ¿Tiene una publicación con cosas interesantes que hacer en San Francisco? san-francisco-events-calendar podría ser un mejor slug que my-guide-to-fun-things-to-do. "],
["nombre-de-dominio.html", "C Nombre de dominio", " C Nombre de dominio Si bien puede usar los nombres de subdominio gratuitos como los provistos por GitHub o Netlify, puede ser una mejor idea tener un nombre de dominio propio. El costo de un dominio principal es mínimo (por lo general, el costo anual es de alrededor de US$ 10), y usted ingresará a un mundo mucho más rico después de comprar un nombre de dominio. Por ejemplo, puede colocar su dominio en cualquier servidor web, puede crear tantos nombres de subdominios como desee e incluso puede configurar sus propias cuentas de correo electrónico usando el dominio o los subdominios. En este apéndice, explicaremos algunos conceptos básicos de nombres de dominio y mencionaremos algunos servicios (gratuitos) para ayudarlo a configurar su nombre de dominio. Antes de sumergirnos en los detalles, queremos delinear la gran imagen de cómo funciona una URL en su navegador web. Supongamos que escribió o hizo clic en un enlace http://www.example.com/foo/index.html en su navegador web. ¿Qué sucede tras bambalinas antes de ver la página web real? Primero, el nombre de dominio debe ser resuelto a través de los servidores de nombres asociados con él. Un servidor de nombres conoce los registros DNS (Sistema de nombres de dominio) de un dominio. Por lo general, buscará los “registros A” para señalar el dominio a la dirección IP de un servidor web. Existen muchos otros tipos de registros DNS, y los explicaremos más adelante. Una vez que se llega al servidor web, el servidor buscará el archivo foo/index.html debajo de un directorio asociado con el nombre de dominio, y devolverá su contenido en la respuesta. Eso es básicamente cómo puedes ver una página web. "],
["registro.html", "C.1 Registro", " C.1 Registro Puede comprar un nombre de dominio de muchos registradores de nombres de dominio. Para permanecer neutral, no vamos a hacer recomendaciones aquí. Puede usar su buscador para buscar un registrador por su cuenta, o pedirle recomendaciones a sus amigos. Sin embargo, nos gustaría recordarle algunas cosas a las que debe prestar atención cuando busque un registrador de nombres de dominio: Debería tener la libertad de transferir su dominio del registrador actual a otros registradores, es decir, no deberían bloquearlo en su sistema. Para transferir un nombre de dominio, se le debe dar un código conocido como “Código de transferencia de autenticación” o “Código de autenticación” o “Clave de transferencia” o algo por el estilo. Debería poder personalizar los servidores de nombres (consulte la sección C.2) de su dominio. De forma predeterminada, cada registrador le asignará sus propios nombres de servidores, y estos nombres de servidores generalmente funcionan muy bien. Sin embargo, hay algunos nombres de servidores especiales que proporcionan servicios más que solo registros DNS, y puede que esté interesado en usarlos. Otras personas pueden buscar libremente su información personal, como su correo electrónico o dirección postal, después de registrar un dominio y enviar esta información al registrador. Esto se denomina “WHOIS Lookup”. Es posible que desee proteger su privacidad, pero su registrador puede requerir un pago adicional. "],
["nombres-de-servidores.html", "C.2 Nombres de servidores", " C.2 Nombres de servidores La razón principal por la que necesitamos nombres de servidores es que queremos usar dominios en lugar de direcciones IP, aunque un dominio no es estrictamente necesario para que pueda acceder a un sitio web. Puede usar la dirección IP si tiene su propio servidor con una IP pública, pero hay muchos problemas con este enfoque. Por ejemplo, las direcciones IP son limitadas (en particular, la IPv4), no son fáciles de memorizar y solo puede alojar un sitio web por dirección IP (sin utilizar otros puertos). Un nombre de servidor de nombres es un motor que dirige los registros DNS de su dominio. El registro DNS más común es el registro A, que asigna un dominio a una dirección IP, de modo que el servidor de alojamiento se puede encontrar a través de su dirección IP cuando se accede a un sitio web a través de un dominio. Presentaremos dos tipos más de registros DNS en la sección ??: registros CNAME y MX. En la mayoría de los casos, los nombres de servidores predeterminados provistos por el registrador de su dominio deberían ser suficientes, pero falta una tecnología especial en la mayoría de nombres de servidores: aplanamiento CNAME. Solo necesita esta tecnología si desea establecer un registro CNAME para su dominio apex. El único caso de uso que yo sepa es cuando aloja su sitio web a través de Netlify, pero desea utilizar el dominio Apex en lugar del subdominio www, por ejemplo, si desea usar example.com en lugar de www.example.com. Para hacer uso de esta tecnología, podría considerar Cloudflare, que proporciona esta característica DNS de forma gratuita. Básicamente, todo lo que necesita hacer es apuntar los servidores de nombres de su dominio a los servidores de nombres proporcionados por Cloudflare (de la forma *.ns.cloudflare.com). "],
["resgistro-dns.html", "C.3 Resgistro DNS", " C.3 Resgistro DNS Hay muchos tipos de registros DNS , y es posible que vea una lista completa en Wikipedia.. Los tipos más comúnmente utilizados pueden ser A, CNAME y registros MX. La figura @ref(fig: cloudflare-dns) muestra un subconjunto de registros DNS de mi dominio yihui.name en Cloudflare, lo que puede darle una idea de cómo son los registros DNS. Puede consultar registros DNS utilizando herramientas de línea de comandos como dig o una aplicación proporcionada por Google: https://toolbox.googleapps.com/apps/dig/. FIGURA C.1: Algunos registros DNS del dominio yihui.name en Cloudflare. Un dominio apex puede tener cualquier cantidad de subdominios. Puede establecer registros DNS para el dominio apex y cualquier subdominio. Puede ver en la figura @ref(fig: cloudflare-dns) que tengo varios subdominios, por ejemplo, slides.yihui.name y xran.yihui.name. Como hemos mencionado, un registro A señala un dominio o subdominio a una dirección IP del servidor host. No utilicé ningún registro A para mis dominios, ya que todos los servicios que uso, como Updog, GitHub Pages y Netlify, son compatibles con los registros CNAME. Un registro CNAME es un alias que señala un dominio a otro. La ventaja de utilizar CNAME sobre A es que no tiene que vincular un dominio a una dirección IP fija. Por ejemplo, el registro CNAME para t.yihui.name es twitter-yihui.netlify.com. Este último dominio es proporcionado por Netlify, y no necesito saber dónde alojan realmente el sitio web. Son libres de mover el host de twitter-yihui.netlify.com, y no necesitaré actualizar mi registro de DNS. Cada vez que alguien visita el sitio web t.yihui.name, el navegador web enrutará el tráfico al dominio establecido en el registro CNAME. Tenga en cuenta que esto es diferente de la redirección, es decir, que la URL t.yihui.name no se redirigirá explícitamente a twitter-yihui.netlify.com (aún se ve la primera en la barra de direcciones de su navegador). Normalmente, puede establecer cualquier registro DNS para el dominio Apex, excepto CNAME, pero configuré un registro CNAME para mi dominio Apex yihui.name, y esto se debe a que Cloudflare admite el aplanamiento CNAME. Para obtener más información sobre este tema, puede leer la publicación “WWW o no WWW,” por Netlify. Personalmente, prefiero no usar el subdominio www.yihui.name para mantener mis URL cortas, así que establezco un registro CNAME tanto para el dominio principal yihui.name como para el subdominio www, y Netlify redirigirá automáticamente el www subdominio al dominio apex. Dicho esto, si es un principiante, puede ser un poco más fácil configurar y usar el subdominio www, como lo sugiere Netlify. Tenga en cuenta que www es un subdominio convencional que suena como un dominio de apex, pero realmente no lo es; puede seguir esta convención o no como lo desee. Para los servicios de correo electrónico, llegué lo suficientemente temprano “cibernauta”, y cuando registré mi nombre de dominio, Google todavía ofrecía servicios gratuitos de correo electrónico a propietarios de dominios personalizados. Así es como puedo tener un buzón personalizado xie@yihui.name. Ahora tendrá que pagar por G Suite. En la figura @ref(fig: cloudflare-dns) puede ver que he configurado algunos MX (siglas en inglés de “intercambio de correo”) registros que apuntan a algunos servidores de correo de Google. Por supuesto, Google no es la única opción posible cuando se trata de buzones personalizados. Migadu dice ser el “alojamiento de correo electrónico más asequible”. Puede probar su plan gratuito y ver si le gusta. A menos que vaya a usar su buzón personalizado extensivamente y para fines profesionales, el plan gratuito puede ser suficiente. De hecho, puede crear una dirección de alias en Migadu para reenviar correos electrónicos a sus otras cuentas de correo electrónico (como Gmail) si no le importa un buzón personalizado real. Migadu ha proporcionado instrucciones detalladas sobre cómo establecer los registros MX para su dominio. "],
["topicos-avanzados.html", "D Tópicos avanzados", " D Tópicos avanzados En este apéndice, hablamos de algunos temas avanzados que pueden ser de interés para desarrolladores y usuarios avanzados. "],
["mas-opciones-globales.html", "D.1 Más opciones globales", " D.1 Más opciones globales Hay algunas opciones globales más avanzadas además de las introducidas en la sección @ref(opciones globales), y se enumeran en la Tabla D.1. TABLA D.1: Unas opciones globales un poco más avanzadas. Option name Default Meaning blogdown.hugo.dir El directorio ejecutable de Hugo blogdown.method html El método de construcción para R Markdown blogdown.publishDir El directorio de publicación para previsualización local blogdown.widgetsID TRUE IDs incrementales para HTML widgets? Si desea instalar Hugo en una ruta personalizada, puede establecer la opción global blogdown.hugo.dir en un directorio para almacenar el ejecutable Hugo antes de llamar a install_hugo(), por ejemplo, options(blogdown.hugo.dir = '~/Downloads/hugo_0.20.1/'). Esto puede ser útil para que usted use una versión específica de Hugo para un sitio web específico,43 O guarde una copia de Hugo en una unidad USB junto con su sitio web. La opción blogdown.method se explica en la sección D.9. Cuando el proyecto de su sitio web está bajo control de versiones en RStudio IDE, la vista previa continua del sitio puede ser lenta, si contiene cientos de archivos o más. El directorio de publicación predeterminado es public/ en el directorio raíz del proyecto, y siempre que realice un cambio en la fuente que desencadena una reconstrucción, RStudio estará ocupado rastreando los cambios de archivos en el directorio public/. La demora antes de que vea el sitio web en RStudio Viewer puede durar 10 segundos o incluso más. Es por eso que ofrecemos la opción blogdown.publishDir. Puede establecer un directorio de publicación temporal para generar el sitio web, y este directorio no debe estar bajo el mismo proyecto de RStudio, por ejemplo, options (blogdown.publishDir = '../public_site'), lo que significa que el sitio web se generará para el directorio public_site/ en el directorio padre del proyecto actual. La opción blogdown.widgetsID solo es relevante si el origen de su sitio web está bajo control de versiones y tiene widgets HTML en el sitio web. Si esta opción es TRUE (valor predeteminado), los ID aleatorios de los HTML widgets se cambiarán a ID incrementales en el resultado HTML, por lo que es poco probable que estos ID cambien cada vez que recompile su sitio web; de lo contrario, cada vez obtendrá diferentes ID aleatorios. Puede establecer esta opción por proyecto. Consulte la sección @ref(opciones globales) para obtener detalles.↩ "],
["livereload.html", "D.2 LiveReload", " D.2 LiveReload Como mencionamos brevemente en la sección ??, puede usar blogdown::serve_site() para obtener una vista previa de un sitio web, y la página web se reconstruirá automáticamente y se volverá a cargar en su navegador web cuando el archivo fuente se modifica y se guarda. Esto se llama “LiveReload”. Hemos proporcionado dos enfoques para LiveReload. El enfoque predeterminado es a través de servr::httw(), que vigilará continuamente el directorio del sitio web en busca de cambios de archivos y reconstruirá el sitio cuando se detecten cambios. Este enfoque tiene algunos inconvenientes: Es relativamente lento porque el sitio web se regenera por completo cada vez. Esto puede no ser un problema real para Hugo, porque Hugo suele ser lo suficientemente rápido: se tarda aproximadamente un milisegundo en generar una página, por lo que un sitio web con mil páginas solo puede tardar aproximadamente un segundo en regenerarse por completo. El servidor demonizado (vea la sección 1.4 puede no funcionar. Si no está preocupado por los problemas anteriores, le recomendamos que use el enfoque predeterminado; de lo contrario, puede configurar la opción global options(blogdown.generator.server = TRUE) para usar un enfoque alternativo a LiveReload, que se basa en el soporte nativo para LiveReload del generador de sitios estáticos. Por el momento, esto solo se ha probado contra sitios web basados en Hugo. No funciona con Jekyll y tampoco tuvimos éxito con Hexo. Este enfoque alternativo requiere la instalación de dos paquetes R adicionales: processx (???) y later (???). Puede utilizar este enfoque cuando trabaje principalmente en publicaciones de Markdown sencillas en lugar de publicaciones de R Markdown, porque puede ser mucho más rápido obtener una vista previa de las publicaciones de Markdown utilizando el servidor web de Hugo. El servidor web puede ser detenido por blogdown::stop_server(), y siempre se detendrá cuando la sesión en R finalice, por lo que puede reiniciar su sesión en R si stop_server() no puede detener el servidor por alguna razón. El servidor web se establece a través del comando hugo server (ver su documentación para más detalles). Puede pasar argumentos de línea de comandos a través de la opción global blogdown.hugo.server. El valor predeterminado para esta opción es c('-D', '-F'), lo que significa mostrar las publicaciones preliminares y futuras en la vista previa. Queremos resaltar un argumento especial --navigateToChanged en una versión reciente de Hugo, que le pide a Hugo que navegue automáticamente a la página modificada. Por ejemplo, puede establecer las opciones: options(blogdown.hugo.server = c(&#39;-D&#39;, &#39;-F&#39;, &#39;--navigateToChanged&#39;)) Luego, cuando edite un archivo fuente bajo content/, Hugo le mostrará automáticamente la página de salida correspondiente en el navegador web. Tenga en cuenta que Hugo presenta el sitio web desde la memoria de forma predeterminada, por lo que no se generarán archivos para public/. Si necesita publicar la carpeta public/ manualmente, deberá compilar manualmente el sitio web a través de blogdown::hugo_build() o blogdown::build_site(). "],
["local-preview.html", "D.3 Construyendo un sitio web para vista previa local", " D.3 Construyendo un sitio web para vista previa local La función blogdown::build_site() tiene un argumento local que por defecto es FALSE, lo que significa construir el sitio web para publicación en lugar de vista previa local. El modo local = TRUE es principalmente para blogdown::serve_site() para presentar el sitio web localmente. Hay tres diferencias principales entre local = FALSE y TRUE. Cuando local = TRUE: La opción baseurl en config.toml se reemplaza temporalmente por &quot;/&quot; aunque haya configurado una URL completa como &quot;http://www.example.com/&quot;.44 es porque cuando un sitio web se va a obtener una vista previa localmente, los enlaces deben hacer referencia a los archivos locales. Por ejemplo, se debe usar /about/index.html en lugar del enlace completohttp://www.example.com/about/index.html; la función serve_site() sabe que /about/index.html significa el archivo bajo el directorio public/, y puede buscarlo y mostrarle el contenido, de lo contrario, su navegador lo llevará al sitio web http://www.example.com en lugar de mostrar un archivo local. Las publicaciones en borrador y futuras siempre se muestran cuando local = TRUE, pero no cuando local = FALSE. Esto es para que pueda obtener una vista previa del borrador y futuras publicaciones localmente. Si conoce la línea de comandos de Hugo significa que se llama al comando hugo con las banderas -D -F, o equivalentemente, --buildDrafts --buildFuture. Hay un mecanismo de almacenamiento en caché para acelerar la creación de su sitio web: un archivo Rmd no se volverá a compilar cuando su archivo de salida *.html sea más reciente (en términos de tiempo de modificación de archivos). Si desea forzar build_site(local = TRUE) para recompilar el archivo Rmd incluso si es anterior al resultado HTML, debe eliminar el resultado HTML o editar el archivo Rmd para que su hora de modificación sea más reciente. Este mecanismo de almacenamiento en caché no se aplica a local = FALSE, es decir, build_site(local = FALSE)siempre recompilará todos los archivos Rmd, porque cuando desee publicar un sitio, es posible que deba recompilarlo todo para asegurarse de que el sitio está completamente regenerado. Si tiene fragmentos de código que consumen mucho tiempo en cualquier archivo Rmd, debe usar cualquiera de estos métodos para ahorrar tiempo: Active el almacenamiento en caché de knitr para la pérdida de tiempo de los trozos de código, i.e., la opción de chunk cache = TRUE. No llame build_site(), sino blogdown::hugo_build() en su lugar . Este último no compila ningún archivo Rmd, simplemente ejecuta el comando hugo para construir el sitio. Utilice este método solo si está seguro de que sus archivos Rmd no necesitan ser recompilados. No necesita preocuparse por estos detalles si su sitio web se genera automáticamente desde la fuente a través de un servicio como Netlify, que hará uso de baseurl y no usar -D -F de forma predeterminada. Si publica manualmente la carpeta public/, debe tener más cuidado: Si su sitio web no funciona sin el baseurl completo, o si no desea que se publiquen los borradores o las publicaciones futuras, no debe publicar el directorio public/ generado por serve_site(). Siempre ejecute blogdown::build_site() o blogdown::hugo_build() antes de subir este directorio a un servidor web. Si sus borradores y publicaciones futuras contienen información (sensible al tiempo), se recomienda mucho eliminar el directorio /public/ antes de reconstruir el sitio para publicarlo todo el tiempo, porque Hugo nunca lo elimina, y su información confidencial puede ser presentada por una determinada llamada build_site(local = TRUE) la última vez y la dejarla en el directorio. Si el sitio web es realmente importante, y necesita asegurarse de que no se arruinará nada cada vez que lo publique, coloque el directorio /public/ bajo control de versiones, para que pueda ver qué archivos se cambiaron antes de publicar el nuevo sitio. Si su baseurl contiene un subdirectorio, será reemplazado por el nombre del subdirectorio. Por ejemplo, para baseurl=&quot; http://www.example.com/project/ &quot;, build_site(local =TRUE) eliminará temporalmente el nombre de dominio y solo usará el valor /project/.↩ "],
["funciones.html", "D.4 Funciones del paquete de blogdown", " D.4 Funciones del paquete de blogdown Hay aproximadamente 20 funciones exportadas en el paquete blogdown, y muchas más funciones no exportadas. Las funciones exportadas están documentadas y puede usarlas después de library(blogdown) (o mediante blogdown ::). Las funciones no exportadas no están documentadas, pero puede acceder a ellas a través de blogdown::: (la sintaxis de tres puntos). Este paquete no es muy complicado y consta de solo 1800 líneas de código en R (el número viene dado por el comando de conteo de palabras wc): Puede consultar el código fuente (https://github.com/rstudio/blogdown) si quiere saber más acerca de una función no exportada. En esta sección, enumeramos de forma selectiva algunas funciones exportadas y no exportadas en el paquete para su referencia. D.4.1 Funciones exportadas Instalación: Puede instalar Hugo con install_hugo(), actualizar Hugo con update_hugo(), e instalar un tema de Hugo con install_theme(). Paquetes de comandos de Hugo: hugo_cmd() es un paquete de system2('hugo', ...), y todas las funciones posteriores ejecutan comandos específicos de Hugo basados en esta función de paquete general; hugo_version() ejecuta el comando hugo version (i.e., system2('hugo', 'version') en R); hugo_build() ejecuta hugo con parámetros opcionales; new_site() ejecuta hugo new site; new_content() ejecuta hugo new para crear un nuevo archivo de contenido, y new_post() es un paquete basado en new_content() para crear una nueva publicación de blog con metadatos YAML apropiados y nombre de archivo; hugo_convert() ejecuta hugo convert; hugo_server() ejecuta hugo server. Formato de salida: html_page() es la única función de formato de salida R Markdown en el paquete. Está heredada desde bookdown::html_document2(), que a su vez está heredada de rmarkdown::html_document(). Necesita leer la documentación de estas dos funciones para conocer los posibles argumentos. La sección ?? tiene información más detallada al respecto. Funciones de ayuda: shortcode() es una función de ayuda para escribir abreviatura de Hugo {{% %}} en un post Rmd; shortcode_html() escribe {{&lt; &gt;}}. Presentar un sitio: serve_site() inicia un servidor web local para construir y obtener una vista previa de un sitio de forma continua; puede detener el servidor a través de stop_server(), o reiniciar su sesión en R. Manejando metadatos YAML: find_yaml() se puede usar para encontrar archivos de contenido que contengan un campo YAML especificado con valores especificados; find_tags() y find_categories() son funciones de contenedor basadas en find_yaml() para unir etiquetas y categorías específicas en archivos de contenido, respectivamente; count_yaml() se puede usar para calcular las frecuencias de los campos especificados. D.4.2 Funciones no exportadas Algunas funciones no se exportan en este paquete porque es poco probable que los usuarios promedio las utilicen directamente, y enumeramos un subconjunto de ellas a continuación: Puede encontrar la ruta al ejecutable de Hugo a través de blogdown:::find_hugo(). Si el ejecutable se puede encontrar a través de la variable de entorno PATH, simplemente devuelve 'hugo'. La función auxiliar modify_yaml() se puede usar para modificar los metadatos YAML de un archivo. Tiene un argumento ... que toma campos YAML arbitrarios, por ejemplo, blogdown:::modify_yaml('foo.md', author = 'Frida Gomam', date = '2015-07-23') cambiará el campo author en el archivo foo.md a Frida Gomam, y date a 2015-07-23. Hemos mostrado el uso avanzado de esta función en la sección ??. También hemos mencionado una serie de funciones para limpiar publicaciones de Markdown en la sección 4.1. Incluyendo process_file(), remove_extra_empty_lines(), process_bare_urls(), normalize_chars(), remove_highlight_tags(), y fix_img_tags(). En la sección @ref(vista previa local), mencionamos un mecanismo de almacenamiento en caché basado en el tiempo de modificación del archivo. Se implementa en blogdown:::require_rebuild(), que toma dos argumentos de nombres de archivos. El primer archivo es el archivo de salida, y el segundo es el archivo de origen. Cuando el archivo fuente es anterior al archivo de salida, o el archivo de salida no existe o está vacío, esta función devuelve TRUE. La función blogdown:::Rscript() es una función de contenedor para ejecutar el comando Rscript, que básicamente significa ejecutar un script R en una nueva sesión R. Mencionamos esta función en el capítulo 5. "],
["rutas-de-figuras-y-otras-dependencias-dep-path.html", "D.5 Rutas de figuras y otras dependencias {# dep-path}", " D.5 Rutas de figuras y otras dependencias {# dep-path} Una de las tareas más desafiantes en el desarrollo del paquete blogdown es manejar adecuadamente los archivos de dependencia de las páginas web. Si todas las páginas de un sitio web estuvieran en texto plano sin dependencias como imágenes o librerías de JavaScript, hubiera sido mucho más fácil desarrollar el paquete blogdown. Después de que blogdown compila cada documento Rmd en HTML, intentará detectar las dependencias (si las hay) del código fuente HTML y las copiará en la carpeta static/, para que Hugo las copie luego en public/ . La detección depende de las rutas de las dependencias. De forma predeterminada, todas las dependencias, como las representaciones R y las librerías para HTML widgets, se generan en el directorio foo_files/ si la Rmd se llama foo.Rmd. Específicamente, los gráficos R se generan a foo_files/figure-html/ y el resto de los archivos bajo foo_files/ son típicamente de HTML widgets. Los gráficos de R bajo content/*/foo_files/figure-html/ se copian a static/*/foo_files/figure-html/, y las rutas en las etiquetas HTML como &lt;img src=&quot;foo_files/figure-html/bar.png&quot;/&gt; se sustituyen por /*/foo_files/figure-html/bar.png. Tenga en cuenta que la barra diagonal indica el directorio raíz del sitio web publicado, y la sustitución funciona porque Hugo copiará */foo_files/figure-html/ de static/ a public/. Cualquier otro archivo bajo foo_files/ se trata como archivo de dependencia de HTML widgets, y se copiará a static/rmarkdown-libs/. Las rutas originales en HTML también serán sustituidos en consecuencia, por ejemplo, del &lt;script src = &quot;foo_files/jquery/jquery.min.js&quot;&gt; a &lt;script src =&quot;/rmarkdown-libs/jquery/jquery.min.js &quot;&gt;. No importa si estos archivos son generados por HTML widgets o no. Los enlaces en el sitio web publicado serán correctos y normalmente ocultos a los lectores de las páginas.45 No debe modificar la opción knitr chunk fig.path o cache.path a menos que el proceso anterior sea completamente claro para usted, y quiera manejar las dependencias usted mismo. En los casos poco frecuentes en los que blogdown no detecta y copia algunas de sus dependencias (p. ej., osó un paquete de HTML widgets bastante sofisticado que escribe archivos en rutas personalizadas), tiene dos opciones posibles: No ignore _files$ en la opción ignoreFiles en config.toml, no personalice la opción permalinks, y configure la opción uglyURLs en true. De esta forma, blogdown no sustituirá las rutas que no puede reconocer, y Hugo copiará estos archivos a public/. Las ubicaciones de archivo relativas del archivo *.html y sus dependencias seguirán siendo las mismas cuando se copien en public/, de modo que todos los enlaces continuarán funcionando. Si elige ignorar _files$ o ha personalizado la opción permalinks, debe asegurarse de que blogdown pueda reconocer las dependencias. Un enfoque es usar la ruta devuelta por la función auxiliar blogdown::dep_path() para escribir archivos de dependencia adicionales. Básicamente, esta función devuelve la opción actual fig.path en knitr, que por defecto es *_files/figure-html/. Por ejemplo, puede generar un trazado manualmente bajo dep_path(), y blogdown lo procesará automáticamente (copie el archivo y sustituya la ruta de la imagen). Si no entiende todos estos detalles técnicos, le recomendamos que use la primera opción, y deberá sacrificar los enlaces permanentes personalizados y las URL limpias (por ejemplo, /about.html en lugar de /about/). Con esta opción, también puede personalizar la opción fig.path para fragmentos de código si lo desea. Por ejemplo, un lector no verá la etiqueta &lt;script&gt; en una página, por lo que realmente no importa lo que su atributo src parece siempre que sea una ruta que realmente existe.↩ "],
["html-widgets.html", "D.6 HTML widgets", " D.6 HTML widgets No recomendamos utilizar diferentes HTML widgets de muchos paquetes de R en la misma página, ya que es probable que genere conflictos en JavaScript. Por ejemplo, si su tema utiliza la librería jQuery, puede entrar en conflicto con la librería jQuery utilizada por un determinado HTML widget. En este caso, puede cargar de forma condicional la librería jQuery del tema configurando un parámetro en los metadatos YAML de su publicación y revisando la plantilla Hugo que carga jQuery. A continuación se muestra el código de ejemplo para cargar jQuery condicionalmente en una plantilla de Hugo: {{ if not .Params.exclude_jquery}} &lt;script src=&quot;path/to/jquery.js&quot;&gt;&lt;/script&gt; {{ end }} Luego, si configura exclude_jquery: true en los metadatos YAML de una publicación, la jQuery del tema no se cargará, por lo que no habrá conflictos cuando los HTML widgets también dependan de jQuery. Otra solución es el paquete widgetframe (???). Resuelve este problema incorporando HTML widgets en &lt;iframe&gt;&lt;/iframe&gt;. Como un iframe está aislado de la página web principal en la que está incrustado, no habrá conflictos de JavaScript. Un widget generalmente no tiene el ancho completo en la página. Para establecer su ancho al 100%, puede usar la opción de fragmento de código out.width =&quot;100%&quot;. "],
["control-de-versiones.html", "D.7 Control de versiones", " D.7 Control de versiones Si los archivos fuente de su sitio web están bajo control de versión , le recomendamos que agregue al menos estos dos nombres de carpeta a su archivo .gitignore: blogdown public El directorio blogdown/ se usa para almacenar archivos de caché, y es probable que sean inútiles para el sitio web publicado. Solo knitr puede usarlos, y el sitio web publicado no dependerá de estos archivos. El directorio public/ debe ignorarse si su sitio web va a ser (re)incorporado automáticamente en un servidor remoto como Netlify. Como mencionamos en la sección ??, las gráficas de R se copiarán a static/, por lo que puede ver nuevos archivos en GIT luego de renderizar un archivo Rmd que tenga salida de gráficos. Debe agregar y confirmar estos nuevos archivos en GIT, ya que el sitio web los usará. Aunque no es relevante para blogdown, los usuarios de macOS deben recordar ignorar .DS_Store y los usuarios de Windows deben ignorar Thumbs.db. Si está relativamente familiarizado con GIT, hay una técnica especial que puede serle útil para administrar los temas de Hugo, que se llama “GIT submodules”. Un submódulo en GIT le permite administrar una carpeta particular del repositorio principal utilizando un repositorio remoto diferente. Por ejemplo, si utilizó el hugo-lithium-theme predeterminado de mi repositorio de GitHub, es posible que desee sincronizarlo con mi repositorio de vez en cuando, porque puedo actualizarlo de vez en cuando. Puede agregar el submódulo GIT a través de la línea de comando: git submodule add \\ https://github.com/yihui/hugo-lithium-theme.git \\ themes/hugo-lithium-theme Si existe la carpeta themes/hugo-lithium-theme, debe eliminarla antes de agregar el submódulo. Luego puede ver una cadena SHA asociada a la “carpeta” themes/hugo-lithium-theme en el estado de GIT de su repositorio principal que indica la versión del submódulo. Tenga en cuenta que solo verá la cadena SHA en lugar del contenido completo de la carpeta. La próxima vez que quiera sincronizarse con mi repositorio, puede ejecutar el comando: git submodule update --recursive --remote En general, si está satisfecho con el aspecto de su sitio web, no necesita administrar el tema con los submódulos de GIT. Es posible que las actualizaciones futuras en el repositorio upstream no sean realmente lo que desea. En ese caso, una copia física y fija del tema es más apropiada para usted. "],
["default-plantilla.html", "D.8 La plantilla por defecto en HTML", " D.8 La plantilla por defecto en HTML Como mencionamos en la sección ??, el formato de salida predeterminado para un documento Rmd en blogdown es blogdown::html_page. Este formato transfiere una plantilla HTML mínima a Pandoc de manera predeterminada: $for(header-includes)$ $header-includes$ $endfor$ $if(highlighting-css)$ &lt;style type=&quot;text/css&quot;&gt; $highlighting-css$ &lt;/style&gt; $endif$ $for(css)$ &lt;link rel=&quot;stylesheet&quot; href=&quot;$css$&quot; type=&quot;text/css&quot; /&gt; $endfor$ $for(include-before)$ $include-before$ $endfor$ $if(toc)$ &lt;div id=&quot;$idprefix$TOC&quot;&gt; $toc$ &lt;/div&gt; $endif$ $body$ $for(include-after)$ $include-after$ $endfor$ Puede encontrar este archivo de plantilla a través de blogdown:::pkg_file('resources', 'template-minimal.html') en R, y esta ruta de archivo es el valor predeterminado del argumento template de html_page(). Puede cambiar esta plantilla predeterminada, pero debe entender qué se supone que debe hacer esta plantilla primero. Si está familiarizado con las plantillas de Pandoc, debe tener en cuenta que esta no es una plantilla HTML completa, por ejemplo, no tiene las etiquetas &lt;html&gt;, &lt;head&gt;, o &lt;body&gt;. Eso es porque no necesitamos ni queremos que Pandoc nos devuelva un documento HTML completo. Lo principal que queremos que Pandoc haga es convertir nuestro documento Markdown a HTML, y darnos el cuerpo del documento HTML, que está en la variable de plantilla $body$. Una vez que tengamos el cuerpo, podemos pasarlo a Hugo, y Hugo usará su propia plantilla para incrustar el cuerpo y generar el documento HTML completo. Vamos a explicar esto con un ejemplo mínimo. Supongamos que tenemos un documento R Markdown foo.Rmd: --- title: &quot;Hola mundo&quot; author: &quot;Yihui Xie&quot; --- Encontré un paquete llamado **blogdown**. Primero se convierte a un archivo HTML foo.html a través de html_page(), y tenga en cuenta que los metadatos YAML se ignoran por ahora: Encontré un paquete llamado &lt;strong&gt;blogdown&lt;/strong&gt;. Luego blogdown leerá los metadatos YAML del archivo fuente Rmd e insertará los metadatos en el archivo HTML para que se convierta en: --- title: &quot;Hola mundo&quot; author: &quot;Yihui Xie&quot; --- Encontré un paquete llamado &lt;strong&gt;blogdown&lt;/strong&gt;. Este es el archivo que Hugo debe recoger y eventualmente convertir a una página HTML de un sitio web. Como Pandoc procesó el cuerpo de Markdown para HTML, Hugo básicamente usará el HTML. Así es como eludimos el motor Markdown BlackFriday de Hugo. Además de $body$, puede haber notado otras variables de plantilla de Pandoc como $header-includes$, $css$, $include-before$, $toc$, y $include-after$. Estas variables permiten personalizar el formato html_page. Por ejemplo, si desea generar una tabla de contenido y aplicar una hoja de estilo CSS adicional a una página determinada, puede establecer toc en true y pasar la ruta de la hoja de estilo al argumento css de html_page(), por ejemplo, --- title: &quot;Hola mundo&quot; author: &quot;Yihui Xie&quot; output: blogdown::html_page: toc: true css: &quot;/css/my-style.css&quot; --- "],
["métodos.html", "D.9 Diferentes métodos de construcción", " D.9 Diferentes métodos de construcción Si su sitio web no contiene ningún archivo Rmd, es muy sencillo presentarlo, solo una llamada al sistema al comando hugo. Cuando su sitio web contiene archivos Rmd, blogdown ha proporcionado dos métodos de representación para compilar estos archivos Rmd. Se puede construir un sitio web usando la función blogdown::build_site(): build_site(local = FALSE, method = c(&quot;html&quot;, &quot;custom&quot;), run_hugo = TRUE) Como se menciona en la sección 1.4, el valor predeterminado del argumento método está determinado por la opción global blogdown.method, y puede establecer esta opción en .Rprofile. Para method = 'html',build_site() renderiza *.Rmd a *.html, y *.Rmarkdown a *.markdown, y mantiene los *.html/*.markdown archivos de salida bajo el mismo directorio que los archivos *.Rmd/*.Rmarkdown. Un archivo Rmd puede generar dos directorios para figuras (*_files/) y caché (*_caché/), respectivamente, si tiene salida de gráficos o HTML widgets (Vaidyanathan et al. 2018) en los fragmentos de código R, o habilitada la opción de fragmento cache = TRUE para el almacenamiento en caché. En el directorio de figuras, habrá un subdirectorio figure-html/ que contiene los archivos de salida de trazado, y posiblemente otros subdirectorios que contengan dependencias HTML de widgets HTML (por ejemplo, jquery/). El directorio de figuras se mueve a /static/, y el directorio de caché se mueve a /blogdown/. Después de ejecutar build_site(), su sitio web está listo para ser compilado por Hugo. Esto le da la libertad de usar servicios de implementación como Netlify (capítulo ??), donde ni R ni blogdown están disponibles, pero Hugo sí lo está. Para method = 'custom', build_site() no procesará ningún archivo R Markdown ni llamará a Hugo para construir el sitio. No importa qué método elija usar, build_site() siempre buscará un script en R /R/build.R y lo ejecutará si existe. Esto le da total libertad para hacer lo que quiera para el sitio web. Por ejemplo, puede llamar a knitr::knit() para compilar Rmd a Markdown (*.md) en este script de R en lugar de usar rmarkdown::render(). Esta característica está diseñada para usuarios avanzados que están realmente familiarizados con el paquete knitr46 Y Hugo u otros generadores de sitios web estáticos (ver capítulo 5). Cuando R/build.R existe y method = 'html', los archivos R Markdown se tejen primero, luego se ejecuta el script R/build.R, y finalmente se llama a Hugo para construir el sitio web. References "],
["personal-experience.html", "E Personal Experience", " E Personal Experience I started blogging at blogchina.com in 2005, moved to blog.com.cn, then MSN Space, and finally purchased my own domain yihui.name and a virtual host. I first used a PHP application named Bo-Blog, then switched to WordPress, and then Jekyll. Finally I moved to Hugo. Although I have moved several times, all my posts have been preserved, and you can still see my first post in Chinese in 2005. I often try my best not to introduce broken links (which lead to the 404 page) every time I change the backend of my website. When it is too hard to preserve the original links of certain pages, I will redirect the broken URLs to the new URLs. That is why it is important for your system to support redirections, and in particular, 301 redirections (Netlify does a nice job here). Here are some of my redirection rules: https://github.com/rbind/yihui/blob/master/static/_redirects. For example, http://yihui.name/en/feed/ was the RSS feed of my old WordPress and Jekyll blogs in English, and Hugo generates the RSS feed to /en/index.xml instead, so I need to redirect /en/feed/ to /en/index.xml. Google has provided several tools to help you know more information about your website. For example, Google Analytics can collect visitor statistics and give speed suggestions for your website. Google Webmasters can show you the broken links it finds. I use these tools frequently by myself. I firmly believe in the value of writing. Over the years, I have written more than 1000 posts in Chinese and English. Some are long, and most are short. The total size of these text files is about 5 Mb. In retrospect, most posts are probably not valuable to general readers (some are random thoughts, and some are my rants), but I feel I benefitted a lot from writing in two aspects: If I sit down and focus on writing a small topic for a while, I often feel my thoughts will become clearer. A major difference between writing and talking is that you can always reorganize things and revise them when writing. I do not think writing on social media counts. 140 characters may well be thoughtful, but I feel there is so much chaos there. It is hard to lay out systematic thoughts only through short messages, and these quick messages are often quickly forgotten. I know some bloggers are very much against comments, so they do not open comments to the public. I have not had a very negative experience with comments yet. On the contrary, I constantly find inspirations from comments. For example, I was thinking if it was possible to automatically check R packages on the cloud through Travis CI. At that time (April 2013), I believe not many people in the R community had started using Travis CI, although I’m not sure if I was the first person experimenting with this idea. I felt Travis CI could be promising, but it did not support R back then. Someone named Vincent Arel-Bundock (I still do not know him) told me a hack in a comment, which suddenly lit up my mind and I quickly figured out a solution. In October 2013, Craig Citro started more solid work on the R support on Travis CI. I do not know if he saw my blog post. Anyway, I think Travis CI has made substantial impact on R package developers, which is a great thing for the R community. Yet another relatively small benefit is that I often go to my own posts to learn some technical stuff that I have forgotten. For example, I find it difficult to remember the syntax of different types of zero-width assertions in Perl-like regular expressions: (?=...), (?!...), (?&lt;=...), and (?&lt;!...). So I wrote a short blog post and gave myself a few minimal examples. After going back to that post a few times, finally I can remember how to use these regular expressions. "],
["references.html", "References", " References "]
]
