# Hugo

En este capítulo, presentaremos brevemente\index{Hugo} Hugo (https://gohugo.io), el generador de sitios estáticos en el que se basa **blogdown**. Este capítulo no pretende reemplazar la documentación oficial de Hugo, sino proporcionar una guía para aquellos que recién están comenzando con Hugo. En caso de duda, consulte la documentación oficial de Hugo.

## Sitios estáticos y Hugo {#static-sites}

Un sitio estático\index{Sitio estático} a menudo consiste en archivos HTML (con dependencias externas opcionales como imágenes y bibliotecas de JavaScript), y el servidor web envía exactamente el mismo contenido al navegador web sin importar quién visita las páginas web. No hay computación dinámica en el servidor cuando se solicita una página. En contraste, un sitio dinámico se basa en un lenguaje del lado del servidor para hacer cierta informática y envía contenido potencialmente diferente dependiendo de las diferentes condiciones. Un lenguaje común es PHP, y un ejemplo típico de un sitio dinámico es un foro web. Por ejemplo, cada usuario tiene una página de perfil, pero generalmente esto no significa que el servidor haya almacenado una página de perfil HTML diferente para cada usuario. En cambio, el servidor obtendrá los datos del usuario de una base de datos y renderizará la página de perfil de forma dinámica.

Para un sitio estático, cada URL que visita a menudo tiene un archivo HTML correspondiente almacenado en el servidor, por lo que no es necesario calcular nada antes de presentar el archivo a los visitantes. Esto significa que los sitios estáticos tienden a ser más rápidos en tiempo de respuesta que los sitios dinámicos, y también son mucho más fáciles de implementar, ya que la implementación simplemente significa copiar archivos estáticos a un servidor. Un sitio dinámico a menudo se basa en bases de datos, y tendrá que instalar más paquetes de software para presentar un sitio dinámico. Para obtener más ventajas de los sitios estáticos, lea la [introducción](https://gohugo.io/overview/introduction/) en el sitio web de Hugo.


Existen muchos generadores de sitios estáticos existentes, incluyendo Hugo, [Jekyll,](http://jekyllrb.com) y [Hexo,](https://hexo.io) etc. La mayoría de ellos puede construir sitios web de propósito general, pero a menudo se utilizan para construir blogs.

Amamos a Hugo por muchas razones, pero hay algunas que se destacan. A diferencia de otros generadores de sitios estáticos, la instalación de Hugo es muy simple porque proporciona un único archivo ejecutable sin dependencias para la mayoría de los sistemas operativos (consulte la sección \@ref(instalación)). También se diseñó para procesar cientos de páginas de contenido más rápido que los generadores de sitios estáticos comparables y, según los informes, puede presentar una página en aproximadamente 1 milisegundo. Por último, la comunidad de usuarios de Hugo es muy activa tanto en el [foro de discusión de Hugo](https://discuss.gohugo.io) y en los [issues de GitHub.](https://github.com/gohugoio/hugo/issues)

Aunque creemos que Hugo es un fantástico generador de sitios estáticos, en realidad hay una única característica importante que falta: el soporte para R Markdown. Ese es básicamente el objetivo del paquete **blogdown**.^[Otra motivación fue una manera más fácil de crear nuevas páginas o publicaciones. Los generadores de sitios estáticos a menudo proporcionan comandos para crear nuevas publicaciones, pero a menudo tiene que abrir y modificar el nuevo archivo creado a mano después de usar estos comandos. Estaba muy frustrado por esto, porque estaba buscando una interfaz gráfica de usuario donde simplemente pudiera completar el título, el autor, la fecha y otra información sobre una página, luego poder comenzar a escribir el contenido de inmediato. Es por eso que proporcioné el complemento de RStudio "New Post" y la función `blogdown::new_post()`. En los últimos años, lo odié cada vez que estaba a punto de crear una nueva publicación, ya sea a mano o a través de la línea de comandos de Jekyll. Finalmente, me volví adicto a los blogs una vez que terminé el complemento de RStudio.] Esta función faltante significa que no puede generar resultados fácilmente usando el código de R en sus páginas web, ya que solo puede usar documentos estáticos de Markdown. Además, el motor de Markdown predeterminado de Hugo es "Blackfriday", que es menos poderoso que Pandoc.^[El soporte de Pandoc se ha agregado en un pull request de Hugo: https://github.com/gohugoio/hugo/pull/4060. Sin embargo, creo que el soporte es bastante limitado, y le recomiendo que use el formato R Markdown, porque con el soporte oficial de Pandoc en Hugo, no puede personalizar las opciones de la línea de comandos de Pandoc, la renderización no está en caché (podría ser lento), y no podrá usar ninguna extensión de Markdown del paquete **bookdown** (como la numeración de los títulos de las figuras).]


Hugo usa una estructura especial de archivos y carpetas para crear su sitio web (Figura \@ref(fig:folders)). El resto de este capítulo brindará más detalles sobre los siguientes archivos y carpetas:

- `config.toml`
- `content/`
- `static/`
- `themes/`
- `layouts/`

(ref:folders) Posibles archivos y carpetas creados cuando crea un nuevo sitio usando **blogdown**.

```{r folders, fig.cap='(ref:folders)', echo=FALSE, fig.align='center', out.width='100%'}
knitr::include_graphics('images/folder-structure.png')
```

## Configuración

El primer archivo que puede ver es el archivo configuration\index{config.toml} o `config` en su directorio raíz, en el que puede establecer configuraciones globales de su sitio. Puede contener opciones como el título y la descripción de su sitio, así como otras opciones globales como enlaces a sus redes sociales, el menú de navegación y la URL base de su sitio web.

Al generar su sitio, Hugo buscará primero un archivo llamado `config.toml`. Si no puede encontrar uno, continuará buscando `config.yaml`.^[Hugo también admite `config.json`, pero **blogdown** no lo admite, por lo que no recomendamos que lo use.] Como la mayoría de los temas de Hugo contienen sitios de ejemplo que envían archivos `config.toml`, y el formato TOML\index{TOML} (Tom's Obvious, Minimal Language) parece ser más popular en la comunidad de Hugo, hablaremos principalmente de `config.toml` aquí.

Recomendamos que utilice la sintaxis TOML solo para el archivo de configuración (también puede usar YAML si lo prefiere), y use YAML como el formato de datos para los metadatos de las páginas y publicaciones de R Markdown, porque R Markdown y **blogdown** son totalmente compatibles solo con YAML\index{YAML}.^[TOML tiene sus ventajas, pero creo que no son significativas en el contexto de los sitios web de Hugo. Es un dolor tener que conocer otro idioma, TOML, cuando YAML significa "Yet Another Markup Language". No estoy seguro de si el cómic XKCD se aplica en este caso: https://xkcd.com/927/.] Si tiene un sitio web que ya ha utilizado TOML, puede usar `blogdown::hugo_convert (unsafe = TRUE)` para convertir los datos de TOML a YAML, pero primero asegúrese de hacer una copia de seguridad del sitio web porque sobrescribirá los archivos de Markdown.

La documentación de Hugo no utiliza TOML o YAML consistentemente en sus ejemplos, lo que puede ser confuso. Preste mucha atención al formato de configuración al copiar ejemplos en su propio sitio web.

### Sintaxis TOML

Si no está familiarizado con la sintaxis de TOML, le daremos una breve descripción general y podrá leer la [documentación completa](https://github.com/toml-lang/toml) para conocer los detalles.

TOML se compone de pares clave-valor separados por signos iguales:

```js
key = value
```

Cuando desee editar una configuración en el archivo TOML, simplemente cambie el valor. Los valores que son cadenas de caracteres deben estar entre comillas, mientras que los valores booleanos deben estar minúsculos y descubiertos.

Por ejemplo, si desea darle a su sitio el título "Mi Sitio Impresionante" y usar URL relativas en lugar de las URL absolutas predeterminadas, puede tener las siguientes entradas en su archivo `config.toml`.

```js
title = "Mi sitio impresionante"

relativeURLs = true
```

La mayoría de las variables globales de su sitio web se ingresan en el archivo `config.toml` exactamente de esta manera.

Más adelante en su archivo `config`, puede observar algunos valores entre paréntesis como este:

```js
[social]
    github  = "https://github.com/rstudio/blogdown"
    twitter = "https://twitter.com/rstudio"
```

Esta es una tabla en el lenguaje TOML y Hugo los usa para completar información en otras páginas dentro de su sitio. Por ejemplo, la tabla anterior rellenará la variable `.Site.Social` en las plantillas de su sitio (más información sobre esto en la sección \@ref(templates)).

Por último, puede encontrar algunos valores en corchetes dobles como este:

```js
[[menu.main]]
    name = "Blog"
    url = "/blog/"

[[menu.main]]
    name = "Categories"
    url = "/categories/"

[[menu.main]]
    name = "About"
    url = "/about/"
```

En TOML, los corchetes dobles se usan para indicar una matriz de tablas. Hugo interpreta esta información como un menú. Si el código anterior se encuentra en un archivo `config.toml`, el sitio web resultante tendrá enlaces a las páginas Blog, Categorías y Acerca de en el menú principal del sitio. La ubicación y el estilo de ese menú se especifican en otra parte, pero aquí se definen los nombres de las opciones de cada menú y los enlaces a cada sección.

El archivo `config.toml` es diferente para cada tema. Asegúrese de que cuando elija un tema, lea su documentación a fondo para comprender lo que hace cada una de las opciones de configuración (más sobre los temas en la sección \@ref(temas)).

### Opciones

Todas las opciones incorporadas\index{opciones} que puede establecer para Hugo se enumeran en https://gohugo.io/overview/configuration/. Puede cambiar cualquiera de estas opciones, excepto `contentDir`, que está codificado en `content` en **blogdown**. Nuestra recomendación general es que será mejor que no modifique los valores predeterminados a menos que comprenda las consecuencias. Enumeramos algunas opciones que pueden ser de su interés:

- `baseURL`: Normalmente tiene que cambiar el valor de esta opción a la URL base\index{baseURL} de su sitio web. Algunos temas de Hugo pueden tenerlo configurado para `http://replace-this-with-your-hugo-site.com/` o `http://www.example.com/` en sus sitios de ejemplo, pero asegúrese de reemplazarlos con su propia URL (consulte el capítulo \@ref(implementación) y el apéndice \@ref(nombre-de-dominio) para obtener más información sobre la publicación de sitios web y la obtención de nombres de dominio). Tenga en cuenta que esta opción puede ser una URL con un subtrayecto, si su sitio web se publicará en una subruta de un nombre de dominio, e.g., `http://www.example.com/docs/`.

- `enableEmoji`: Puede\index{Emoji} configurarlo en `true` para que pueda usar [Emoticones Emoji ](http://www.emoji-cheat-sheet.com) como `:smile:` en Markdown.

- `permalinks`: Reglas para generar enlaces permanentes\index{permalinks} de sus páginas. Por defecto, Hugo usa nombres de archivos completos bajo `content/` para generar links, e.g., `content/about.md` será renderizado a `public/about/index.html`, y `content/post/2015-07-23-foo.md` será renderizado a `public/post/2015-07-23-foo/index.html`, entonces los enlaces reales son `/about/` y `/post/2015-07-23-foo/` en el sitio web. Aunque no es necesario establecer reglas personalizadas para enlaces permanentes, es común ver enlaces de la forma `/YYYY/mm/dd/post-title/`. Hugo le permite usar varias piezas de información sobre un archivo fuente para generar un enlace, como la fecha (año, mes y día), título y nombre de archivo, etc. El enlace puede ser independiente del nombre del archivo. Por ejemplo, puede pedirle a Hugo que presente páginas bajo `content/post/` usando la fecha y el título de sus enlaces:

    ```js
    [permalinks]
        post = "/:year/:month/:day/:title/"
    ```
    
    Personalmente, le recomiendo que use la variable \index{Slug} `:slug`^[Una slug es simplemente una cadena de caracteres que puede usar para identificar una publicación específica. Una slug no cambiará, incluso si el título cambia. Por ejemplo, si decide cambiar el título de su publicación de "Me encanta el blogdown" a "Por qué blogdown es el mejor paquete de la historia" y usó el título de la publicación en la URL, sus enlaces anteriores ahora se romperán. Si, en cambio, especifica la URL a través de un slug (algo así como "blogdown-love"), puede cambiar el título tantas veces como quiera y no terminará con enlaces rotos.] En lugar de `:títle`:
    
    ```js
    [permalinks]
        post = "/:year/:month/:day/:slug/"
    ```
    
    Esto se debe a que el título de su publicación puede cambiar, y es probable que no desee que el enlace a la publicación cambie; de lo contrario, debe redirigir el enlace anterior al nuevo enlace, y habrá otros tipos de problemas, como los comentarios de Disqus. La variable `:slug` vuelve a `:title` si un campo llamado `slug` no está establecido en los metadatos YAML de la publicación. Puede establecer un slug fijo para que el enlace a la publicación siempre sea fijo y tendrá la libertad de actualizar el título de su publicación.
    
    Puede encontrar una lista de todas las posibles variables que usted puede usar en la opción `permalinks` en https://gohugo.io/extras/permalinks/. 

- `publishDir`: El directorio bajo el cual quiere generar el sitio web.

- `theme`: El nombre del directorio de Hugo bajo `themes/`.

- `ignoreFiles`: Una lista de patrones de archivo (expresiones regulares) para Hugo con el fin de que ignore\index{ignoreFiles} ciertos archivos cuando se construye el sitio. Recomiendo que especifique al menos estos patrones `["\\.Rmd$", "\\.Rmarkdown$", "_files$", "_cache$"]`. Debería ignorar los archivos  `.Rmd` porque **blogdown** los compilará a `.html`, y le basta a Hugo usar los archivos `.html`. No hay necesidad de que Hugo construya archivos `.Rmd`, y actualmente Hugo no sabe cómo. Los directorios con sufijos `_files` y `_cache` deberían ser ignorados porque contienen archivos auxiliares una vez que un archivo Rmd se compila, y **blogdown** los almacenará. Hugo no los debería copiar de nuevo al directorio `public/`.

- `uglyURLs`: Por defecto, Hugo genera URLs "limpias"\index {uglyURLs}. Esto puede ser un poco sorprendente y requiere que comprenda cómo funcionan las URL cuando su buscador obtiene una página de un servidor. Básicamente, Hugo genera `foo/index.html` para `foo.md` de forma predeterminada en lugar de `foo.html`, porque el primero le permite visitar la página a través de la URL limpia `foo/` sin `index.html`. La mayoría de los servidores web entienden solicitudes como `http://www.example.com/foo/` y presentan `index.html` bajo `foo/`. Si prefiere el mapeo estricto de `*.md` a `*.html`, puede habilitar las URL "feas" configurando `uglyURLs` en `true`. 

- `hasCJKLanguage`: Si su sitio web se encuentra principalmente en CJK\index{hasCJKLanguage} (chino, coreano y japonés), le recomiendo que configure esta opción en `true`, para que el resumen automático y el recuento de palabras de Hugo funcionen mejor.

Además de las opciones incorporadas de Hugo, puede establecer otras opciones arbitrarias en `config.toml`. Por ejemplo, es muy común ver una opción llamada `params`, que se usa ampliamente en muchos temas de Hugo. Cuando vea una variable `.Site.Params.FOO` en un tema de Hugo, significa una opción `FOO` que se establece bajo `[params]` en `config.toml`, por ejemplo, `.Site.Params.author` es `Frida Gomam` con el siguiente archivo de configuración:

```js
[params]
    author = "Frida Gomam"
    dateFormat = "2006/01/02"
```

El objetivo de todas estas opciones es evitar cualquier problema de codificación en los temas de Hugo, de modo que los usuarios puedan editar fácilmente un único archivo de configuración para aplicar el tema a sus sitios web, en lugar de pasar por muchos archivos HTML y realizar cambios uno por uno.

## Contenido

La estructura del directorio `content/` puede ser arbitraria. Una estructura común es que hay algunas páginas estáticas bajo la raíz de `content/`, y un subdirectorio `post/` que contiene publicaciones de blog:

```bash
├── _index.md
├── about.md
├── vitae.md
├── post/
│   ├── 2017-01-01-foo.md
│   ├── 2017-01-02-bar.md
│   └── ...
└── ...
```

### Metadatos YAML

Cada página debe comenzar con los metadatos YAML\index {YAML} que especifican información como el título, la fecha, el autor, las categorías, las etiquetas, etc. Según el tema específico de Hugo y las plantillas que use, algunos de estos campos pueden ser opcionales.

Entre todos los campos de YAML, queremos llamar su atención sobre estos:

- `draft`: Puede marcar un documento como borrador\index {Borrador} configurando `draft: true` en sus metadatos YAML. Los borradores de mensajes no se mostrarán si el sitio se compila mediante `blogdown::build_site()` o `blogdown::hugo_build ()`, pero se presentarán en el modo de vista previa local (consulte la sección \@ref(local-preview))

- `publishdate`: Puede especificar una fecha futura \index{Publicar fecha} para publicar un post. Al igual que en las publicaciones preliminares, las publicaciones futuras solo se presentan en el modo de vista previa local.

- `weight`: Este campo puede tomar un valor numérico para indicarle a Hugo el orden de las páginas al ordenarlas \index{Peso del Post}; por ejemplo, cuando genera una lista de todas las páginas debajo de un directorio y dos publicaciones tienen la misma fecha, puede asignar diferentes ponderaciones para obtener el orden deseado en la lista.

- `slug`: Una cadena de caracteres como la cola de la URL. Es particularmente útil cuando define reglas personalizadas para URL permanentes (vea la sección \@ref(opciones)).

### Cuerpo

Como mencionamos en la sección \@ref(formato de salida), su publicación puede escribirse en R o Markdown. Tenga cuidado con las diferencias de sintaxis entre los dos formatos cuando escribe el cuerpo de una publicación.

### Código corto

Además de todas las características de Markdown, Hugo proporciona una característica útil llamada "códigos abreviados". Puede usar un shortcode\index{Shortcode} en el cuerpo de su publicación. Cuando Hugo presenta la publicación, puede generar automáticamente un fragmento de HTML basado en los parámetros que pasa al código corto. Esto es conveniente porque no tiene que escribir o insertar una gran cantidad de código HTML en su publicación. Por ejemplo, Hugo tiene un código abreviado incorporado para incrustar tarjetas de Twitter. Normalmente, así es como inserta una tarjeta de Twitter (Figura \@ref(fig: jtleek-tweet)) en una página:

```html
<blockquote class="twitter-tweet">
  <p lang="en" dir="ltr">Anyone know of an R package for
    interfacing with Alexa Skills?
    <a href="https://twitter.com/thosjleeper">@thosjleeper</a>
    <a href="https://twitter.com/xieyihui">@xieyihui</a>
    <a href="https://twitter.com/drob">@drob</a>
    <a href="https://twitter.com/JennyBryan">@JennyBryan</a>
    <a href="https://twitter.com/HoloMarkeD">@HoloMarkeD</a> ?
  </p>
  &mdash; Jeff Leek (@jtleek)
  <a href="https://twitter.com/jtleek/status/852205086956818432">
    April 12, 2017
  </a>
</blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8">
</script>
```

```{r jtleek-tweet, fig.cap='A tweet by Jeff Leek.', fig.align='center', out.width='80%', echo=FALSE}
knitr::include_graphics('images/jtleek-tweet.png')
```

Si usa el código abreviado, todo lo que necesita en el documento fuente de reducción es:

```go
{{< tweet 852205086956818432 >}}
```

Básicamente, solo necesita pasar el ID del tweet a un código corto llamado `tweet`. Hugo buscará el tweet automáticamente y renderizará el fragmento de HTML por usted. Para obtener más información sobre los códigos abreviados, consulte https://gohugo.io/extras/shortcodes/.

Se supone que los códigos cortos funcionan solo en documentos de Markdown. Para usar códigos abreviados en R Markdown en lugar de Markdown simple, debe llamar a la función `blogdown::shortcode()`, e.g.,

````markdown
`r ''````{r echo=FALSE}
blogdown::shortcode('tweet', '852205086956818432')
```
````

## Temas

Un tema de Hugo\index{Temas} es una colección de plantillas y archivos opcionales del sitio web, como archivos CSS y JavaScript. En pocas palabras, un tema define el aspecto de su sitio web después de que su contenido fuente se presente a través de las plantillas.

Hugo ha proporcionado una gran cantidad de temas aportados por los usuarios en https://themes.gohugo.io. A menos que sea un diseñador web experimentado, es mejor que comience desde un tema existente aquí. La calidad y la complejidad de estos temas varían mucho, y debe elegir uno con precaución. Por ejemplo, puede ver el número de estrellas de un repositorio de temas en GitHub, así como si el repositorio todavía está relativamente activo. No recomendamos utilizar un tema que no se haya actualizado durante más de un año.

En esta sección, explicaremos cómo funciona el tema predeterminado en **blogdown**, que también puede brindarle algunas ideas sobre cómo comenzar con otros temas.

### El tema por defecto

El tema predeterminado en **blogdown**, hugo-lithium-theme\index{Hugo Lithium Theme}, está alojado en GitHub en https://github.com/yihui/hugo-lithium-theme. Fue escrito originalmente por Jonathan Rutheiser, y he realizado varios cambios en él. Este tema es adecuado para quienes prefieren estilos mínimos y desean crear un sitio web con algunas páginas y algunas publicaciones en el blog.

Normalmente, un repositorio de temas en GitHub tiene un archivo `README`, que también sirve como la documentación del tema. Después de leerlo, el siguiente archivo para buscar es `config.toml` en el directorio `exampleSite`, que contiene configuraciones de muestra para un sitio web basado en este tema. Si un tema no tiene un archivo `README` o` exampleSite`, probablemente no debería usarlo.

El `config.toml` del tema hugo-lithium-theme contiene las siguientes opciones:

```js
baseurl = "/"
relativeurls = false
languageCode = "en-us"
title = "A Hugo website"
theme = "hugo-lithium-theme"
googleAnalytics = ""
disqusShortname = ""
ignoreFiles = ["\\.Rmd$", "\\.Rmarkdown", "_files$", "_cache$"]

[permalinks]
    post = "/:year/:month/:day/:slug/"

[[menu.main]]
    name = "About"
    url = "/about/"
[[menu.main]]
    name = "GitHub"
    url = "https://github.com/rstudio/blogdown"
[[menu.main]]
    name = "Twitter"
    url = "https://twitter.com/rstudio"

[params]
    description = "A website built through Hugo and blogdown."

    highlightjsVersion = "9.11.0"
    highlightjsCDN = "//cdn.bootcss.com"
    highlightjsLang = ["r", "yaml"]
    highlightjsTheme = "github"

    MathJaxCDN = "//cdn.bootcss.com"
    MathJaxVersion = "2.7.1"

[params.logo]
    url = "logo.png"
    width = 50
    height = 50
    alt = "Logo"
```

Algunas de estas opciones pueden ser obvias para comprender, y algunas pueden necesitar explicaciones:

- `baseurl`: Puede\index{baseURL} configurar esta opción después, después de tener un nombre de dominio para su sitio web. No olvide la barra inclinada.

- `relativeurls`: Esto es opcional. Puede configurarlo como `true` solo si tiene la intención de ver su sitio web localmente a través de su visor de archivos, por ejemplo, hacer doble clic en un archivo HTML y verlo en su navegador. Esta opción tiene como valor predeterminado `false` en Hugo, y significa que su sitio web debe ser visto a través de un servidor web, por ejemplo, `blogdown::serve_site()` ha proporcionado un servidor web local, por lo que puede obtener una vista previa localmente cuando `relativeurls = false`.

- `title`: El título de su sitio web. Típicamente esto se muestra en la barra de título del buscador web o sobre una pestaña de página.

- `theme`: El nombre del directorio del tema. Debe tener mucho cuidado al cambiar los temas, porque un tema puede ser drásticamente diferente de otro tema en términos de configuraciones. Es muy posible que un tema diferente no funcione con su `config.toml` actual. De nuevo, debe leer la documentación de un tema para saber qué opciones son compatibles o requeridas.

- `googleAnalytics`: El ID de seguimiento de Google Analytics\index{Google Analytics} (por ejemplo, `UA-000000-2`). Puede inscribirse en https://analytics.google.com para obtener un IDde seguimiento.

- `disqusShortname`: El ID de Disqus\index{Comentarios de Disqus} que creó durante el proceso de configuración de la cuenta en https://disqus.com. Esto es necesario para habilitar los comentarios en su sitio.^[Como mencionamos en la sección \@ref(sitios estáticos), **blogdown** genera contenido estático e inmutable. Para agregar algo dinámico y siempre cambiante (como la posibilidad de que sus seguidores dejen comentarios), debe incorporar un sistema de comentarios externo como Disqus.] Tenga en cuenta que debe configurar un `baseurl` funcional y publicar su sitio web antes de que los comentarios de Disqus pueda funcionar.

- `ignoreFiles` y `permalinks`: Estas opciones han sido explicadas en la sección \@ref(opciones).

- `menu`: Esta lista de opciones especifica el texto y la URL de los elementos del menú en la parte superior. Ver la figura \@ref(fig:lithium) para una página de muestra. Puede cambiar o agregar más elementos de menú. Si desea ordenar los artículos, puede asignar un `peso` a cada artículo, e.g.,

    ```js
    [[menu.main]]
        name = "Home"
        url = "/"
        weight = 1
    [[menu.main]]
        name = "About"
        url = "/about/"
        weight = 2
    [[menu.main]]
        name = "GitHub"
        url = "https://github.com/rstudio/blogdown"
        weight = 3
    [[menu.main]]
        name = "CV"
        url = "/vitae/"
        weight = 4
    [[menu.main]]
        name = "Twitter"
        url = "https://twitter.com/rstudio"
        weight = 5
    ```
    
    En el ejemplo anterior, agregué un elemento de menú `CV` con la URL `/vitae/`, y se supone que hay un archivo fuente correspondiente `vitae.md` debajo del directorio `content/` para generar la página `/vitae/index.html`, por lo que el enlace realmente funcionará.

- `params`: Diversos parámetros\index{params} del tema.

    - `description`: Una breve descripción de su sitio web. No es visible en las páginas web (solo puede verlo desde la fuente HTML), pero debe dar a los motores de búsqueda una pista sobre su sitio web.
    
    - `highlightjs*`: Estas opciones se usan para configurar las librerías de JavaScript\index{Syntax Highlighting} [highlight.js](https://highlightjs.org) para resaltar la sintaxis de los bloques de código sobre las páginas web. Puede cambiar la versión (e.g., `9.12.0`), el hosto CND (e.g., usando [cdnjs](https://cdnjs.com): `//cdnjs.cloudflare.com/ajax/libs`), agregar más lenguajes (e.g., `["r", "yaml", "tex"]`), y cambiar el tema (e.g., `atom-one-light`). Vea https://highlightjs.org/static/demo/ para todos los lenguajes y temas que highlight.js soporta.
    
    - `MathJax*`: La librería de JavaScript MathJax\index{MathJax} puede renderizar expresiones matemáticas en LaTeX sobre páginas web. De la misma forma que `highlightjsCDN`, puede especificar el host CDN de MathJax, e.g., `//cdnjs.cloudflare.com/ajax/libs`, y puede especificar la versión de MathJax.
    
    - `logo`: Una lista de opciones para definir el logo\index{Logo} del sitio web. Por defecto, la imagen `logo.png` bajo el directorio `static/` se usa.

Si quiere ser un desarrollador de temas y comprender completamente todos los detalles técnicos sobre estas opciones, debe comprender las plantillas de Hugo, que presentaremos en la sección \@ref(plantillas).

## Plantillas

A Hugo theme consists of two major components: templates\index{Templates}, and web assets. The former is essential, and tells Hugo how to render a page.^[The most common functionality of templates is to render HTML pages, but there can also be special templates, for example, for RSS feeds and sitemaps, which are XML files.] The latter is optional but also important. It typically consists of CSS and JavaScript files, as well as other assets like images and videos. These assets determine the appearance and functionality of your website, and some may be embedded in the content of your web pages.

You can learn more about Hugo templates from the official documentation (https://gohugo.io/templates/overview/). There are a great many different types of templates. To make it easier for you to master the key ideas, I created a very minimal Hugo theme, which covers most functionalities that an average user may need, but the total number of lines is only about 150, so we can talk about all the source code of this theme in the following subsection.

### A minimal example

[XMin](https://github.com/yihui/hugo-xmin) is a Hugo theme\index{XMin Theme} I wrote from scratch in about 12 hours. Roughly half an hour was spent on templates, 3.5 hours were spent on tweaking the CSS styles, and 8 hours were spent on the documentation (https://xmin.yihui.name). I think this may be a representative case of how much time you would spend on each part when designing a theme. It is perhaps our nature to spend much more time on cosmetic stuff like CSS than essential stuff like templates. Meanwhile, coding is often easier than documentation.

We will show the source code of the XMin theme. Because the theme may be updated occasionally in the future, you may follow this link to obtain a fixed version that we will talk about in this section: https://github.com/yihui/hugo-xmin/tree/4bb305. Below is a tree view of all files and directories in the theme:

```bash
hugo-xmin/
├── LICENSE.md
├── README.md
├── archetypes
│   └── default.md
├── layouts
│   ├── 404.html
│   ├── _default
│   │   ├── list.html
│   │   ├── single.html
│   │   └── terms.html
│   └── partials
│       ├── foot_custom.html
│       ├── footer.html
│       ├── head_custom.html
│       └── header.html
├── static
│   └── css
│       ├── fonts.css
│       └── style.css
└── exampleSite
    ├── config.toml
    ├── content
    │   ├── _index.md
    │   ├── about.md
    │   ├── note
    │   │   ├── 2017-06-13-a-quick-note.md
    │   │   └── 2017-06-14-another-note.md
    │   └── post
    │       ├── 2015-07-23-lorem-ipsum.md
    │       └── 2016-02-14-hello-markdown.md
    ├── layouts
    │   └── partials
    │       └── foot_custom.html
    └── public
        └── ...
```

`LICENSE.md` and `README.md` are not required components of a theme, but you definitely should choose a license for your source code so that other people can properly use your code, and a `README` can be the brief documentation of your software.

The file `archetypes/default.md` defines the default template based on which users can create new posts. In this theme, `default.md` only provided empty YAML metadata:

```yaml
---
---
```

The most important directories of a theme are `layouts/` and `static/`. HTML templates are stored under `layouts/`, and assets are stored under `static/`.

To understand `layouts/`, you must know some basics about HTML (see Section \@ref(html)) because the templates under this directory are mostly HTML documents or fragments. There are many possible types of subdirectories under `layouts/`, but we are only going to introduce two here: `_default/` and `partials/`.

- The `_default/` directory\index{\_default/} is where you put the default templates for your web pages. In the XMin theme, we have three templates: `single.html`, `list.html`, and `terms.html`.

    - `single.html` is a template\index{single.html} for rendering single pages. A single page basically corresponds to a Markdown document under `content/`, and it contains both the (YAML) metadata and content. Typically we want to render the page title, author, date, and the content. Below is the source code of XMin's `single.html`:
    
        ```html
        {{ partial "header.html" . }}
        <div class="article-meta">
        <h1><span class="title">{{ .Title }}</span></h1>
        {{ with .Params.author }}
        <h2 class="author">{{ . }}</h2>
        {{ end }}
        {{ if .Params.date }}
        <h2 class="date">{{ .Date.Format "2006/01/02" }}</h2>
        {{ end }}
        </div>
        
        <main>
        {{ .Content }}
        </main>
        
        {{ partial "footer.html" . }}
        ```
        
        You see a lot of pairs of double curly braces `{{}}`, and that is how you program the templates using Hugo's variables and functions.
        
        The template starts with a partial template `header.html`, for which you will see the source code soon. For now, you can imagine it as all the HTML tags before the body of your page (e.g., `<html><head>`). Partial templates\index{Partials} are mainly for reusing HTML code. For example, all HTML pages may share very similar `<head></head>` tags, and you can factor out the common parts into partial templates.
        
        The metadata of a page is included in a `<div>` element with the class `article-meta`. We recommend that you assign classes to HTML elements when designing templates, so that it will be easier to apply CSS styles to these elements using class names. In a template, you have access to many variables provided by Hugo, e.g., the `.Title` variable stores the value of the page title, and we write the title in a `<span>` in a first-level header `<h1>`. Similarly, the author and date are written in `<h2>`, but only if they are provided in the YAML metadata. The syntax `{{ with FOO }}{{ . }}{{ end }}` is a shorthand of `{{if FOO }}{{ FOO }}{{ end }}`, i.e., it saves you the effort of typing the expression `FOO` twice by using `{{ . }}`. The method `.Format` can be applied to a date object, and in this theme, we format dates in the form `YYYY/mm/dd` (`2006/01/02` is the way to specify the format in Go).
        
        Then we show the content of a page, which is stored in the variable `.Content`. The content is wrapped in a semantic HTML tag `<main>`.
        
        The template is finished after we include another partial template `footer.html` (source code to be shown shortly).
        
        To make it easier to understand how a template works, we show a minimal example post below:
        
        ```markdown
        ---
        title: Hello World
        author: Frida Gomam
        date: 2017-06-19
        ---
        
        A single paragraph.
        ```
        
        Using the template `single.html`, it will be converted to an HTML page with source code that looks more or less like this (with the header and footer omitted):

        ```html
        <div class="article-meta">
          <h1><span class="title">Hello World</span></h1>
          <h2 class="author">Frida Gomam</h2>
          <h2 class="date">2017/06/19</h2>
        </div>
        
        <main>
          <p>A single paragraph.</p>
        </main>
        ```
        
        For a full example of a single page, you may see https://xmin.yihui.name/about/.

    - `list.html` is the template\index{list.html} for rendering lists of pages, such as a list of blog posts, or a list of pages within a category or tag. Here is its source code:

        ```html
        {{ partial "header.html" . }}
        
        {{if not .IsHome }}
        <h1>{{ .Title }}</h1>
        {{ end }}
        
        {{ .Content }}
        
        <ul>
          {{ range (where .Data.Pages "Section" "!=" "") }}
          <li>
            <span class="date">{{ .Date.Format "2006/01/02" }}</span>
            <a href="{{ .URL }}">{{ .Title }}</a>
          </li>
          {{ end }}
        </ul>
        
        {{ partial "footer.html" . }}
        ```
        
        Again, it uses two partial templates `header.html` and `footer.html`. The expression `{{if not .IsHome }}` means, if this list is not the home page, show the page title. This is because I do not want to display the title on the homepage. It is just my personal preference. You can certainly display the title in `<h1>` on the home page if you want.
        
        The `{{ .Content }}` shows the content of the list. Please note that typically `.Content` is empty, which may be surprising. This is because a list page is not generated from a source Markdown file by default. However, there is an exception. When you write a special Markdown file `_index.md` under a directory corresponding to the list name, the `.Content` of the list will be the content of this Markdown file. For example, you can define the content of your homepage in `content/_index.md`, and the content of the post list page under `content/post/_index.md`.
        
        Next we generate the list using a loop (`range`) through all pages filtered by the condition that the section of a page should not be empty. "Section" in Hugo means the first-level subdirectory name under `content/`. For example, the section of `content/post/foo.md` is `post`. Therefore the filter means that we will list all pages under subdirectories of `content/`. This will exclude pages under the root `content/` directory, such as `content/about.md`.
        
        Please note that the variable `.Data` is dynamic, and its value changes according to the specific list you want to generate. For example, the list page https://xmin.yihui.name/post/ only contains pages under `content/post/`, and https://xmin.yihui.name/note/ only contains pages under `content/note/`. These list pages are automatically generated by Hugo, and you do not need to explicitly loop through the sections `post` and `note`. That is, a single template `list.html` will generate multiple lists of pages according to the sections and taxonomy terms (e.g., categories and tags) you have on your website.

        The list items are represented by the HTML tags `<li>` in `<ul>`. Each item consists of the date, link, and title of a page. You may see https://xmin.yihui.name/post/ for a full example of a list page.

    - `terms.html` is the template\index{terms.html} for the home page of taxonomy terms. For example, you can use it to generate the full list of categories or tags. The source code is below:

        ```html
        {{ partial "header.html" . }}
        
        <h1>{{ .Title }}</h1>
        
        <ul class="terms">
          {{ range $key, $value := .Data.Terms }}
          <li>
            <a href='{{ (print "/" $.Data.Plural "/" $key) | relURL }}'>
              {{ $key }}
            </a>
            ({{ len $value }})
          </li>
          {{ end }}
        </ul>
        
        {{ partial "footer.html" . }}
        ```
        
        Similar to `list.html`, it also uses a loop. The variable `.Data.Terms` stores all terms under a taxonomy, e.g., all category names. You can think of it as a named list in R (called a `map` in Go), with the names being the terms and the values being lists of pages. The variable `$key` denotes the term and `$value` denotes the list of pages associated with this term. What we render in each `<li>` is a link to the term page as well as the count of posts that used this term (`len` is a Go function that returns the length of an object).
        
        Hugo automatically renders all taxonomy pages, and the path names are the plural forms of the taxonomies, e.g., https://xmin.yihui.name/categories/ and https://xmin.yihui.name/tags/. That is the meaning of `.Data.Plural`. The leading `$` is required because we are inside a loop, and need to access variables from the outside scope. The link of the term is passed to the Hugo function `relURL` via a pipe `|` to make it relative, which is good practice because relative links are more portable (independent of the domain name).

- The `partials/` directory is the place to put the HTML fragments to be reused by other templates via the `partial` function. We have four partial templates under this directory:

    - `header.html` main defines\index{header.html} the `<head>` tag and the navigation menu in the `<nav>` tag.

        ```html
        <!DOCTYPE html>
        <html lang="{{ .Site.LanguageCode }}">
          <head>
            <meta charset="utf-8">
            <title>{{ .Title }} | {{ .Site.Title }}</title>
            <link href='{{ "/css/style.css" | relURL }}'
              rel="stylesheet" />
            <link href='{{ "/css/fonts.css" | relURL }}'
              rel="stylesheet" />
            {{ partial "head_custom.html" . }}
          </head>
        
          <body>
            <nav>
            <ul class="menu">
              {{ range .Site.Menus.main }}
              <li><a href="{{ .URL | relURL }}">{{ .Name }}</a></li>
              {{ end }}
            </ul>
            <hr/>
            </nav>
        ```
        
        The `<head>` area should be easy to understand if you are familiar with HTML. Note that we also included a partial template `head_custom.html`, which is empty in this theme, but it will make it much easier for users to add customized code to `<head>` without rewriting the whole template. See Section \@ref(custom-layouts) for more details.
        
        The navigation menu is essentially a list, and each item of the list is read from the variable `.Site.Menus.main`. This means users can define the menu in `config.toml`, e.g., 
      
        ```js  
        [[menu.main]]
            name = "Home"
            url = "/"
        [[menu.main]]
            name = "About"
            url = "/about/"
        ```

        It will generate a menu like this:
        
        ```html
        <ul class="menu">
          <li><a href="/">Home</a></li>
          <li><a href="/about/">About</a></li>
        </ul>
        ```
        
        Hugo has a powerful menu system, and we only used the simplest type of menu in this theme. If you are interested in more features like nested menus, please see the full documentation at http://gohugo.io/extras/menus/.

    - `footer.html` defines the footer\index{footer.html} area of a page and closes the HTML document:

        ```html
          <footer>
          {{ partial "foot_custom.html" . }}
          {{ with .Site.Params.footer }}
          <hr/>
          {{ . | markdownify }}
          {{ end }}
          </footer>
          </body>
        </html>
        ```
        
        The purpose of the partial template `foot_custom.html` is the same as `head_custom.html`; that is, to allow the user to add customized code to the `<footer>` without rewriting the whole template.
        
        Lastly, we use the variable `.Site.Params.footer` to generate a page footer. Note we used the `with` function again. Recall that the syntax `{{ with .Site.Params.footer }}{{ . }}{{ end }}` is a shorthand for `{{if .Site.Params.footer }}{{ .Site.Params.footer }}{{ end }}`. This syntax saves you from typing the expression `.Site.Params.footer` twice by using `{{ . }}` as a placeholder for the variable `footer`, which is defined as a site parameter in our `config.toml` file. The additional function `markdownify` can convert Markdown to HTML (i.e., `{{ . | markdownify }}`. Altogether, this sequence means we can define a `footer` option using Markdown under `params` in `config.toml`, e.g.,
        
        ```js
        [params]
            footer = "&copy; [Yihui Xie](https://yihui.name) 2017"
        ```

There is a special template `404.html`, which Hugo uses to create the 404\index{404.html} page (when a page is not found, this page is displayed):

```html
{{ partial "header.html" . }}

404 NOT FOUND

{{ partial "footer.html" . }}
```

With all templates above, we will be able to generate a website from Markdown source files. You are unlikely to be satisfied with the website, however, because the HTML elements are not styled at all, and the default appearance may not look appealing to most people. You may have noticed that in `header.html`, we have included two CSS files, `/css/style.css` and `/css/fonts.css`.

You can find many existing open-source CSS frameworks online that may be applied to a Hugo theme. For example, the most popular CSS framework may be Bootstrap: http://getbootstrap.com. When I was designing XMin, I wondered how far I could go without using any of these existing frameworks, because they are usually very big. For example, `bootstrap.css` has nearly 10000 lines of code when not minimized. It turned out that I was able to get a satisfactory appearance with about 50 lines of CSS, which I will explain in detail below:

- `style.css` defines all styles except the typefaces:

    ```css
    body {
      max-width: 800px;
      margin: auto;
      padding: 1em;
      line-height: 1.5em;
    }
    ```
    
    The maximum width of the page body is set to 800 pixels because an excessively wide page is difficult to read (`800` is an arbitrary threshold that I picked). The body is centered using the CSS trick `margin: auto`, which means the top, right, bottom, and left margins are automatic. When a block element's left and right margins are `auto`, it will be centered. 
    
    ```css
    /* header and footer areas */
    .menu li { display: inline-block; }
    .article-meta, .menu a {
      text-decoration: none;
      background: #eee;
      padding: 5px;
      border-radius: 5px;
    }
    .menu, .article-meta, footer { text-align: center; }
    .title { font-size: 1.1em; }
    footer a { text-decoration: none; }
    hr {
      border-style: dashed;
      color: #ddd;
    }
    ```
    
    Remember that our menu element is a list `<ul class="menu">` defined in `header.html`. I changed the default display style of `<li>` within the menu to `inline-block`, so that they will be laid out from left to right as inline elements, instead of being stacked vertically as a bullet list (the default behavior).
    
    For links (`<a>`) in the menu and the metadata area of an article, the default text decoration (underlines) is removed, and a light background color is applied. The border radius is set to 5 pixels so that you can see a subtle round-corner rectangle behind each link.
    
    The horizontal rule (`<hr>`) is set to a dashed light-gray line to make it less prominent on a page. These rules are used to separate the article body from the header and footer areas.
    
    ```css
    /* code */
    pre {
      border: 1px solid #ddd;
      box-shadow: 5px 5px 5px #eee;
      padding: 1em;
      overflow-x: auto;
    }
    code { background: #f9f9f9; }
    pre code { background: none; }
    ```
    
    For code blocks (`<pre>`), I apply light gray borders with drop-shadow effects. Every inline code element has a very light gray background. These decorations are merely out of my own peculiar interest and emphasis in code.
    
    ```css
    /* misc elements */
    img, iframe, video { max-width: 100%; }
    main { hyphens: auto; }
    blockquote {
      background: #f9f9f9;
      border-left: 5px solid #ccc;
      padding: 3px 1em 3px;
    }
    
    table {
      margin: auto;
      border-top: 1px solid #666;
      border-bottom: 1px solid #666;
    }
    table thead th { border-bottom: 1px solid #ddd; }
    th, td { padding: 5px; }
    tr:nth-child(even) { background: #eee }
    ```
    
    Embedded elements like images and videos that exceed the page margin are often ugly, so I restrict their maximum width to 100%. Hyphenation is turned on for words in `<main>`. Blockquotes have a gray left sidebar and a light gray background. Tables are centered by default, with only three horizontal rules: the top and bottom borders of the table, and the bottom border of the table head. Table rows are striped to make it easier to read the table especially when the table is wide.

- `fonts.css` is a separate style sheet\index{fonts.css} because it plays a critical role in the appearance of a website, and it is very likely that you will want to customize this file. In most cases, your readers will spend the most time on reading the text on your pages, so it is important to make the text comfortable to read. I'm not an expert in web design, and I just picked Palatino for the body and Lucida Console or Monaco (whichever is available in your system) for the code. It is common to use Google web fonts nowadays. You may try some web fonts and see if you like any of them.
    
    ```css
    body {
      font-family: "Palatino Linotype", "Book Antiqua", Palatino, serif;
    }
    code {
      font-family: "Lucida Console", Monaco, monospace;
      font-size: 85%;
    }
    ```

The two CSS files are placed under the `static/css/` directory of the theme. In the HTML template `header.html`, the path `/css/style.css` refers to the file `static/css/style.css`.

Lastly, this theme provided an example site under `exampleSite/`. The directory structure may be a little confusing because this is a theme instead of a website. In practice, everything under `exampleSite/` should be under the root directory of a website, and the top-level `hugo-xmin/` directory should be under the `themes/` directory of this website, i.e.,

```bash
├── config.toml
├── content/
├── ...
├── themes/
│   └── hugo-xmin/
│
└── ...
```

The example site provides a sample `config.toml`, a home page `_index.md`, an about page `about.md`, two posts under `note/` and two under `post/`. It also overrides the `foot_custom.html` in the theme.

### Implementing more features {#how-to}

The XMin is actually a highly functional theme, but we understand that it may be too minimal for you. There are a few commonly used features (intentionally) missing in this theme, and we will teach you how to add them by yourself if desired. All these features and the source code can be applied to other themes, too.

- **Enable Google Analytics.** Hugo\index{Google Analytics} has provided a built-in partial template. For XMin, you can add

    ```html
    {{ template "_internal/google_analytics.html" . }}
    ```

    to `layouts/partials/foot_custom.html` under the root directory of your website (instead of `themes/hugo-xmin/`), and configure `googleAnalytics` in the `config.toml`. See https://github.com/yihui/hugo-xmin/pull/3 for details, and the HTML source of this page for the JavaScript rendered from the template: https://deploy-preview-3--hugo-xmin.netlify.com.

- **Enable Disqus comments.** Similar to Google Analytics\index{Disqus Comments}, you can add the built-in template

    ```html
    {{ template "_internal/disqus.html" . }}
    ```

    to `foot_custom.html`, and configure the Disqus shortname in `config.toml`. See https://github.com/yihui/hugo-xmin/pull/4 for details, and a preview at https://deploy-preview-4--hugo-xmin.netlify.com.

- **Enable syntax highlighting via highlight.js.** Add this\index{Syntax Highlighting} to `head_custom.html`

    ```html
    <link href="//YOUR-CDN-LINK/styles/github.min.css" rel="stylesheet">
    ```
    
    and this to `foot_custom.html`:
    
    ```html
    <script src="//YOUR-CDN-LINK/highlight.min.js"></script>
    <script src="//YOUR-CDN-LINK/languages/r.min.js"></script>
    
    <script>
    hljs.configure({languages: []});
    hljs.initHighlightingOnLoad();
    </script>
    ```
    
    Remember to replace `YOUR-CDN-LINK` with the link to your preferred CDN host of highlight.js, e.g., `cdn.bootcss.com/highlight.js/9.12.0`. For more information about highlight.js, please see its homepage: https://highlightjs.org. If you need to use other CDN hosts, cdnjs.com is a good choice: https://cdnjs.com/libraries/highlight.js You can also see which languages and CSS themes are supported there.
    
    You may see https://github.com/yihui/hugo-xmin/pull/5 for an actual implementation, and a sample page with syntax highlighting at https://deploy-preview-5--hugo-xmin.netlify.com/post/2016/02/14/a-plain-markdown-post/.

- **Support math expressions through MathJax.** Add the code below\index{MathJax} to `foot_custom.html`.

    ```html
    <script src="//yihui.name/js/math-code.js"></script>
    <script async
    src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    ```
    
    This requires substantial knowledge of JavaScript and familiarity with MathJax to fully understand the code above, and we will leave the explanation of the code to Section \@ref(javascript).
    
    Note that bootcss.com is only one possible CDN host of MathJax, and you are free to use other hosts.

- **Show the table of contents (TOC).** To show a TOC\index{Table of Contents} for R Markdown posts, you only need to add the output format `blogdown::html_page` with the option `toc: true` to YAML:

    ```yaml
    output:
      blogdown::html_page:
        toc: true
    ```
    
    For plain Markdown posts, you have to modify the template `single.html`. The TOC of a post is stored in the Hugo template variable `.TableOfContents`. You may want an option to control whether to show the TOC, e.g., you may add an option `toc: true` to the YAML metadata of a Markdown post to show the TOC. The code below can be added before the content of a post in `single.html`:
    
    ```html
    {{ if .Params.toc }}
    {{ .TableOfContents }}
    {{ end }}
    ```
    
    See https://github.com/yihui/hugo-xmin/pull/7 for an implementation with examples.

- **Display categories and tags in a post if provided in its YAML.** Add the code\index{Tags} below where you want to place the categories and tags in `single.html`, e.g., in `<div class="article-meta"></div>`.

    ```html
    <p class="terms">
      {{ range $i := (slice "categories" "tags") }}
      {{ with ($.Param $i) }}
      {{ $i | title }}:
      {{ range $k := . }}
      <a href='{{ relURL (print "/" $i "/" $k | urlize) }}'>{{$k}}</a>
      {{ end }}
      {{ end }}
      {{ end }}
    </p>
    ```
    
    Basically the code loops through the YAML metadata fields `categories` and `tags`, and for each field, its value is obtained from `.Param`, then we use an inside loop to write out the terms with links of the form `<a href="/tags/foo/">foo</a>`.

    You may see https://github.com/yihui/hugo-xmin/pull/2 for the complete implementation and a preview at https://deploy-preview-2--hugo-xmin.netlify.com/post/2016/02/14/a-plain-markdown-post/.

- **Add pagination.** When you have a large number of posts on a website, you may not want to display the full list on a single page, but show N posts (e.g., N = 10) per page. It is easy to add pagination to a website using Hugo's built-in functions and templates. Instead of looping through all posts in a list template (e.g., `range .Data.Pages`), you paginate the full list of posts using the function `.Paginate` (e.g., `range (.Paginate .Data.Pages)`). Below is a template fragment that you may insert to your template file `list.html`:

    ```html
    <ul>
      {{ $paginator := .Paginate .Data.Pages }}
      {{ range $paginator.Pages }}
      <li>
        <span class="date">{{ .Date.Format "2006/01/02" }}</span>
        <a href="{{ .URL }}">{{ .Title }}</a>
      </li>
      {{ end }}
    </ul>
    {{ template "_internal/pagination.html" . }}
    ```

    See https://github.com/yihui/hugo-xmin/pull/16 for a full implementation.

- **Add a GitHub Edit button or link to a page.** If none\index{GitHub Edit Page} of the above features look exciting to you (which would not surprise me), this little feature is really a great example of showing you the power of plain-text files and static websites, when combined with GitHub (or other services that support the online editing of plain-text files). I believe it would be difficult, if not impossible, to implement this feature in dynamic website frameworks like WordPress.

    Basically, when you browse any text files in a repository on GitHub, you can edit them right on the page by hitting the Edit button (see Figure \@ref(fig:github-edit) for an example) if you have a GitHub account. If you have write access to the repository, you can commit the changes directly online, otherwise GitHub will fork the repository for you automatically, so that you can edit the file in your own repository, and GitHub will guide you to create a pull request to the original repository. When the original owner sees the pull request, he/she can see the changes you made and decide whether to accept them or not or ask you to make further changes. Although the terminology "pull request" is highly confusing to beginners,^[In my opinion, it really should be called "merge request" instead.] it is probably the single greatest feature invented by GitHub, because it makes it so much easier for people to make contributions.
    
    What is really handy is that all you need is a URL of a fixed form to edit a file on GitHub: `https://github.com/USER/REPO/edit/BRANCH/PATH/TO/FILE`. For example, https://github.com/rbind/yihui/edit/master/content/knitr/faq.md, where `USER` is `rbind`, `REPO` is `yihui`, `BRANCH` is `master`, and the file path is `content/knitr/faq.md`.
    
    The key to implementing this feature is the variable `.File.Path`, which gives us the source file path of a page under `content/`, e.g., `post/foo.md`. If your website only uses plain Markdown files, the implementation will be very simple. I omitted the full GitHub URL in `...` below, of which an example could be `https://github.com/rbind/yihui/edit/master/content/`.
    
    ```html
    {{ with .File.Path }}
    <a href="https://github.com/.../{{ . }}">Edit this page</a>
    {{ end }}
    ```

    However, the case is a little more complicated for **blogdown** users, when R Markdown posts are involved. You cannot just use `.File.Path` because it actually points to the `.html` output file from an `.Rmd` file, whereas the `.Rmd` file is the actual source file. The Edit button or link should not point to the `.html` file. Below is the complete implementation that you may add to a template file depending on where you want to show the Edit link (e.g., `footer.html`):

    ```html
    {{ if .File.Path }}
    
    {{ $Rmd := (print .File.BaseFileName ".Rmd") }}
    
    {{ if (where (readDir (print "content/" .File.Dir)) "Name" $Rmd) }}
      {{ $.Scratch.Set "FilePath" (print .File.Dir $Rmd) }}
    {{ else }}
      {{ $.Scratch.Set "FilePath" .File.Path }}
    {{ end }}
    
    {{ with .Site.Params.GithubEdit}}
    <a href='{{ . }}{{ $.Scratch.Get "FilePath" }}'>Edit this page</a>
    {{ end }}
    
    {{ end }}
    ```
    
    The basic logic is that for a file, if the same filename with the extension `.Rmd` exists, we will point the Edit link to the Rmd file. First, we define a variable `$Rmd` to be the filename with the `.Rmd` extension. Then we check if it exists. Unfortunately, there is no function in Hugo like `file.exists()` in R, so we have to use a hack: list all files under the directory and see if the Rmd file is in the list. [`$.Scratch`](http://gohugo.io/extras/scratch/) is the way to dynamically store and obtain variables in Hugo templates. Most variables in Hugo are read-only, and you have to use `$.Scratch` when you want to modify a variable. We set a variable `FilePath` in `$.Scratch`, whose value is the full path to the Rmd file when the Rmd file exists, and the path to the Markdown source file otherwise. Finally, we concatenate a custom option `GithubEdit` in `config.toml` with the file path to complete the Edit link `<a>`. Here is an example of the option in `config.toml`:
    
    ```js
    [params]
      GithubEdit = "https://github.com/rbind/yihui/edit/master/content/"
    ```
    
    Please note that if you use Hugo on Windows to build and deploy your site, you may have to change the file path separators from backslashes to forward slashes, e.g., you may need `{{ $.Scratch.Set "FilePath" (replace ($.Scratch.Get "FilePath") "\\" "/") }}` in the template. To avoid this complication, we do not recommend that you deploy your site through Windows (see Chapter \@ref(deployment) for deployment methods).
    
    You may see https://github.com/yihui/hugo-xmin/pull/6 for an actual implementation with R Markdown examples, and see the footer of this page for the Edit link: https://deploy-preview-6--hugo-xmin.netlify.com. You can actually see a link in the footer of every page, except the lists of pages (because they do not have source files).

```{r github-edit, fig.cap='Edit a text file online on GitHub.', echo=FALSE, fig.align='center', out.width='100%'}
knitr::include_graphics('images/github-edit.png')
```

After you digest the XMin theme and the implementations of additional features, it should be much easier to understand other people's templates. There are a large number of Hugo themes but the primary differences among them are often in styles. The basic components of templates are often similar.

## Custom layouts

It is very likely that you want to customize a theme unless you designed it. The most straightforward way is to simply make changes directly in the theme,^[If you are new to web development, be careful changing content within the theme. Minor changes like colors and font sizes can be found within the CSS files of the theme and can be altered simply with minimal risk of breaking the theme's functionality.] but the problem is that a Hugo theme may be constantly updated by its original author for improvements or bug fixes. Similar to the "you break it, you buy it" policy (the [Pottery Barn rule](https://en.wikipedia.org/wiki/Pottery_Barn_rule)), once you touch someone else's source code, you will be responsible for its future maintenance, and the original author should not be responsible for the changes you made on your side. That means it may not be easy to pull future updates of this theme to your website (you have to carefully read the changes and make sure they do not conflict with your changes), but if you are completely satisfied with the current state of the theme and do not want future updates, it is fine to modify the theme files directly.

A theme author who is aware of the fact that users may customize her theme will typically provide two ways: one is to provide options in `config.toml`, so that you can change these options without touching the template files; the other is to leave a few lightweight template files under `layouts/` in the theme, so that you can override them without touching the core template files. Take the XMin theme for example:

I have two empty HTML files `head_custom.html` and `foot_custom.html` under `layouts/partials/` in the theme. The former will be added inside `<head></head>` of a page, e.g., you can load JavaScript libraries or include CSS style sheets via `<link>`. The latter will be added before the footer of a page, e.g., you may load additional JavaScript libraries or embed Disqus comments there.

The way that you customize these two files is not to edit them directly in the theme folder, but to create a directory `layouts/partials/` under the root directory of your website, e.g., your directory structure may look like this:

```bash
your-website/
├── config.toml
├── ...
├── themes/
│   └── hugo-xmin/
│       ├── ...
│       └── layouts/
│           ├── ...
│           └── partials
│               ├── foot_custom.html
│               ├── footer.html
│               ├── head_custom.html
│               └── header.html
└── layouts
    └── partials
        ├── foot_custom.html
        └── head_custom.html
```

All files under `layouts/` under the root directory will override files with the same relative paths under `themes/hugo-xmin/layouts/`, e.g., the file `layouts/partials/foot_custom.html`, when provided, will override `themes/hugo-xmin/layouts/partials/foot_custom.html`. That means you only need to create and maintain at most two files under `layouts/` instead of maintaining all files under `themes/`. Note that this overriding mechanism applies to all files under `layouts/`, and is not limited to the `partials/` directory. It also applies to any Hugo theme that you actually use for your website, and is not limited to `hugo-xmin`.

## Static files

All files under the `static/` directory\index{Static Directory} are copied to `public/` when Hugo renders a website. This directory is often used to store static web assets like images, CSS, and JavaScript files. For example, an image `static/foo/bar.png` can be embedded in your post using the Markdown syntax `![](/foo/bar.png)`.^[The link of the image depends on your `baseurl` setting in `config.toml`. If it does not contain a subpath, `/foo/bar.png` will be the link of the image, otherwise you may have to adjust it, e.g., for `baseurl = "http://example.com/subpath/"`, the link to the image should be `/subpath/foo/bar.png`.]

Usually a theme has a `static/` folder, and you can partially override its files using the same mechanism as overriding `layouts/` files, i.e., `static/file` will override `themes/theme-name/static/file`. In the XMin theme, I have two CSS files `style.css` and `fonts.css`. The former is the main style sheet, and the latter is a quite small file to define typefaces only. You may want to define your own typefaces, and you can only provide a `static/css/fonts.css` to override the one in the theme, e.g.,

```css
body {
  font-family: "Comic Sans MS", cursive, sans-serif;
}
code {
  font-family: "Courier New", Courier, monospace;
}
```

To R Markdown users, another important application of the `static/` directory is to build Rmd documents with custom output formats, i.e., Rmd documents not using the `blogdown::html_page()` format (see Section \@ref(output-format)). For example, you can generate a PDF or presentations from Rmd documents under this directory, so that Hugo will not post-process them but simply copies them to `public/` for publishing. To build these Rmd files, you must provide a custom build script `R/build.R` (see Section \@ref(methods)). You can write a single line of code in this script\index{blogdown::build\_dir()}:

```r
blogdown::build_dir("static")
```

The function `build_dir()` finds all Rmd files under a directory, and calls `rmarkdown::render()` to build them to the output formats specified in the YAML metadata of the Rmd files. If your Rmd files should not be rendered by a simple `rmarkdown::render()` call, you are free to provide your own code to render them in `R/build.R`. There is a built-in caching mechanism in the function `build_dir()`: an Rmd file will not be compiled if it is older than its output file(s). If you do not want this behavior, you can force all Rmd files to be recompiled every time: `build_dir(force = TRUE)`.

I have provided a minimal example in the GitHub repository [yihui/blogdown-static,](https://github.com/yihui/blogdown-static) where you can find two Rmd examples under the `static/` directory. One is an HTML5 presentation based on the **xaringan** package, and the other is a PDF document based on **bookdown**.

You need to be cautious about arbitrary files under `static/`, due to Hugo's overriding mechanism. That is, everything under `static/` will be copied to `public/`. You need to make sure that the files you render under `static/` will not conflict with those files automatically generated by Hugo from `content/`. For example, if you have a source file `content/about.md` and an Rmd file `static/about/index.Rmd` at the same time, the HTML output from the latter will overwrite the former (both Hugo and you will generate an output file with the same name `public/about/index.html`).
